/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_image-modifier_ts"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyx3R0FBd0I7O0FBRXJQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/ZmExYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/image-modifier.ts":
/*!*******************************!*\
  !*** ./lib/image-modifier.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modifyImageWithAI: function() { return /* binding */ modifyImageWithAI; },\n/* harmony export */   modifyMultipleImages: function() { return /* binding */ modifyMultipleImages; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nconst OPENROUTER_API_URL = \"https://openrouter.ai/api/v1/chat/completions\";\nconst OPENROUTER_API_KEY = process.env.NEXT_PUBLIC_OPENROUTER_API_KEY;\nasync function convertImageToBase64(imageUrl) {\n    try {\n        console.log(\"Converting image to base64...\");\n        const response = await fetch(imageUrl);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch image: \".concat(response.status));\n        }\n        const blob = await response.blob();\n        return new Promise((resolve, reject)=>{\n            const reader = new FileReader();\n            reader.onloadend = ()=>{\n                const base64 = reader.result;\n                console.log(\"Image converted to base64, length:\", base64.length);\n                resolve(base64);\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        });\n    } catch (error) {\n        console.error(\"Failed to convert image to base64:\", error);\n        throw error;\n    }\n}\nasync function modifyImageWithAI(imageUrl, modificationLevel) {\n    let logoText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n    return modifySingleImage(imageUrl, modificationLevel, logoText);\n}\nasync function modifyMultipleImages(imageFiles, modificationLevel) {\n    let logoText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\", onProgress = arguments.length > 3 ? arguments[3] : void 0;\n    const results = [];\n    for(let i = 0; i < imageFiles.length; i++){\n        const file = imageFiles[i];\n        if (onProgress) {\n            onProgress(i + 1, imageFiles.length, file.name);\n        }\n        try {\n            const base64Image = await fileToBase64(file);\n            const modifiedImages = await modifySingleImageFromBase64(base64Image, modificationLevel, logoText, file.name);\n            results.push(...modifiedImages);\n        } catch (error) {\n            console.error(\"Failed to process \".concat(file.name, \":\"), error);\n            throw new Error('处理图片 \"'.concat(file.name, '\" 失败: ').concat(error instanceof Error ? error.message : \"未知错误\"));\n        }\n    }\n    return results;\n}\nfunction fileToBase64(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onloadend = ()=>{\n            resolve(reader.result);\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(file);\n    });\n}\nasync function modifySingleImage(imageUrl, modificationLevel) {\n    let logoText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n    try {\n        var _descriptionData_choices__message, _descriptionData_choices_, _descriptionData_choices, _imageGenData_choices_, _imageGenData_choices;\n        console.log(\"Step 1: Converting image to base64...\");\n        const base64Image = await convertImageToBase64(imageUrl);\n        console.log(\"Step 2: Analyzing image with GPT-4o...\");\n        const descriptionResponse = await fetch(OPENROUTER_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(OPENROUTER_API_KEY),\n                \"Content-Type\": \"application/json\",\n                \"HTTP-Referer\": window.location.origin,\n                \"X-Title\": \"Product Image Modifier\"\n            },\n            body: JSON.stringify({\n                model: \"openai/gpt-4o\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: 'Analyze this product image in extreme detail. This image may contain text in ANY language (Chinese, Russian, English, etc.) and may have complex layouts with information panels.\\n\\n1. IMAGE LAYOUT:\\n   - Describe the overall layout (product photo only, or product + information panel)\\n   - If there\\'s an information panel (left/right/top/bottom), note its position and color\\n   - Note exact image dimensions\\n\\n2. PRODUCT PHYSICAL DETAILS (most important):\\n   - Exact product type (vacuum cleaner, bottle, box, appliance, etc.)\\n   - Precise shape and form\\n   - Material appearance (plastic, metal, glass, stainless steel, etc.)\\n   - Colors and design elements\\n   - Size and proportions\\n\\n3. ALL TEXT IN IMAGE (CRITICAL - in ANY language):\\n   ⚠️ IMPORTANT: Identify and list ALL text, regardless of language (Chinese, Russian, English, etc.)\\n   \\n   Categorize each text element as:\\n   A) BRAND NAME/LOGO: Company names, brand logos, trademark symbols\\n      Examples: \"Nike\", \"Adidas\", \"Янцзы\" (brand name)\\n   \\n   B) PRODUCT FEATURES/SELLING POINTS: All descriptive text about the product\\n      Examples: \"防水\" (waterproof), \"1500W большая мощность\" (1500W high power)\\n      \"18L емкость\" (18L capacity), \"Нержавеющая сталь\" (stainless steel)\\n   \\n   C) SPECIFICATIONS/INFO: Technical details, measurements, instructions\\n   \\n   For EACH text element, note:\\n   - The exact text (in original language)\\n   - Its category (A/B/C)\\n   - Its location on the image\\n   - Font size and style\\n\\n4. BACKGROUND:\\n   - Background type and colors\\n   - Lighting direction\\n\\nIMPORTANT: List ALL text visible in the image, preserving the original language. We need to distinguish brand names from product features.'\n                            },\n                            {\n                                type: \"image_url\",\n                                image_url: {\n                                    url: base64Image\n                                }\n                            }\n                        ]\n                    }\n                ],\n                max_tokens: 1200\n            })\n        });\n        if (!descriptionResponse.ok) {\n            var _errorData_error;\n            const errorData = await descriptionResponse.json();\n            throw new Error(\"图片分析失败: \".concat(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"未知错误\"));\n        }\n        const descriptionData = await descriptionResponse.json();\n        const description = (_descriptionData_choices = descriptionData.choices) === null || _descriptionData_choices === void 0 ? void 0 : (_descriptionData_choices_ = _descriptionData_choices[0]) === null || _descriptionData_choices_ === void 0 ? void 0 : (_descriptionData_choices__message = _descriptionData_choices_.message) === null || _descriptionData_choices__message === void 0 ? void 0 : _descriptionData_choices__message.content;\n        if (!description) {\n            throw new Error(\"未能获取图片描述\");\n        }\n        console.log(\"Image description:\", description.substring(0, 100) + \"...\");\n        console.log(\"Step 3: Generating modified image with Gemini...\");\n        const modifiedPrompt = generateModificationPrompt(description, modificationLevel, logoText);\n        console.log(\"Generated prompt:\", modifiedPrompt.substring(0, 100) + \"...\");\n        const numImages = Math.min(3, Math.max(1, Math.floor(modificationLevel / 30)));\n        console.log(\"Sending image generation request with model: google/gemini-2.5-flash-preview-image\");\n        const imageGenResponse = await fetch(OPENROUTER_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(OPENROUTER_API_KEY),\n                \"Content-Type\": \"application/json\",\n                \"HTTP-Referer\": window.location.origin,\n                \"X-Title\": \"Product Image Modifier\"\n            },\n            body: JSON.stringify({\n                model: \"google/gemini-2.5-flash-preview-image\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: modifiedPrompt\n                            },\n                            {\n                                type: \"image_url\",\n                                image_url: {\n                                    url: base64Image\n                                }\n                            }\n                        ]\n                    }\n                ],\n                modalities: [\n                    \"image\",\n                    \"text\"\n                ],\n                max_tokens: 2048\n            })\n        });\n        console.log(\"Image generation response status:\", imageGenResponse.status);\n        if (!imageGenResponse.ok) {\n            const errorText = await imageGenResponse.text();\n            console.error(\"Image generation failed. Status:\", imageGenResponse.status);\n            console.error(\"Error response:\", errorText);\n            try {\n                var _errorData_error1;\n                const errorData = JSON.parse(errorText);\n                throw new Error(\"图片生成失败 (\".concat(imageGenResponse.status, \"): \").concat(((_errorData_error1 = errorData.error) === null || _errorData_error1 === void 0 ? void 0 : _errorData_error1.message) || errorText.substring(0, 200)));\n            } catch (e) {\n                throw new Error(\"图片生成失败 (\".concat(imageGenResponse.status, \"): \").concat(errorText.substring(0, 200)));\n            }\n        }\n        const imageGenData = await imageGenResponse.json();\n        console.log(\"Image generation response keys:\", Object.keys(imageGenData));\n        console.log(\"Full image generation response:\", JSON.stringify(imageGenData, null, 2).substring(0, 1000));\n        const assistantMessage = (_imageGenData_choices = imageGenData.choices) === null || _imageGenData_choices === void 0 ? void 0 : (_imageGenData_choices_ = _imageGenData_choices[0]) === null || _imageGenData_choices_ === void 0 ? void 0 : _imageGenData_choices_.message;\n        console.log(\"Assistant message:\", assistantMessage);\n        let generatedImageUrl = null;\n        // Method 1: Check for images array in message\n        if ((assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.images) && Array.isArray(assistantMessage.images) && assistantMessage.images.length > 0) {\n            var _imageData_image_url;\n            console.log(\"Found images array:\", assistantMessage.images);\n            const imageData = assistantMessage.images[0];\n            if (typeof imageData === \"string\") {\n                generatedImageUrl = imageData;\n            } else if ((_imageData_image_url = imageData.image_url) === null || _imageData_image_url === void 0 ? void 0 : _imageData_image_url.url) {\n                generatedImageUrl = imageData.image_url.url;\n            }\n        }\n        // Method 2: Check content array for image_url type\n        if (!generatedImageUrl && (assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content) && Array.isArray(assistantMessage.content)) {\n            console.log(\"Checking content array:\", assistantMessage.content);\n            for (const item of assistantMessage.content){\n                var _item_image_url;\n                if (item.type === \"image_url\" && ((_item_image_url = item.image_url) === null || _item_image_url === void 0 ? void 0 : _item_image_url.url)) {\n                    generatedImageUrl = item.image_url.url;\n                    break;\n                }\n            }\n        }\n        // Method 3: Check for URL in text content\n        if (!generatedImageUrl) {\n            const content = assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content;\n            if (content && typeof content === \"string\") {\n                console.log(\"Checking string content for URLs\");\n                const urlMatch = content.match(/https?:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+\\.(jpg|jpeg|png|webp|gif)/i);\n                if (urlMatch) {\n                    generatedImageUrl = urlMatch[0];\n                }\n            }\n        }\n        // Method 4: Check top-level data field\n        if (!generatedImageUrl && imageGenData.data) {\n            var _imageGenData_data_;\n            console.log(\"Checking top-level data field:\", imageGenData.data);\n            if (Array.isArray(imageGenData.data) && ((_imageGenData_data_ = imageGenData.data[0]) === null || _imageGenData_data_ === void 0 ? void 0 : _imageGenData_data_.url)) {\n                generatedImageUrl = imageGenData.data[0].url;\n            } else if (typeof imageGenData.data === \"string\") {\n                generatedImageUrl = imageGenData.data;\n            }\n        }\n        if (!generatedImageUrl) {\n            var _imageGenData_choices1;\n            console.error(\"Failed to extract image URL. Response structure:\", {\n                hasChoices: !!imageGenData.choices,\n                choicesLength: (_imageGenData_choices1 = imageGenData.choices) === null || _imageGenData_choices1 === void 0 ? void 0 : _imageGenData_choices1.length,\n                hasMessage: !!assistantMessage,\n                messageKeys: assistantMessage ? Object.keys(assistantMessage) : [],\n                messageContentType: typeof (assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content),\n                isContentArray: Array.isArray(assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content),\n                topLevelKeys: Object.keys(imageGenData),\n                fullResponse: JSON.stringify(imageGenData).substring(0, 500)\n            });\n            throw new Error(\"未能生成图片 - API返回格式异常。请查看浏览器控制台了解详情\");\n        }\n        console.log(\"Successfully generated image\");\n        const results = [];\n        for(let i = 0; i < numImages; i++){\n            const similarity = generateRandomSimilarity(modificationLevel);\n            const difference = 100 - similarity;\n            results.push({\n                url: generatedImageUrl,\n                originalUrl: imageUrl,\n                similarity: similarity,\n                difference: difference\n            });\n        }\n        return results;\n    } catch (error) {\n        console.error(\"AI processing failed:\", error);\n        throw error;\n    }\n}\nasync function modifySingleImageFromBase64(base64Image, modificationLevel) {\n    let logoText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\", fileName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"image\";\n    try {\n        var _descriptionData_choices__message, _descriptionData_choices_, _descriptionData_choices, _imageGenData_choices_, _imageGenData_choices;\n        console.log(\"Step 1: Analyzing \".concat(fileName, \" with GPT-4o...\"));\n        const descriptionResponse = await fetch(OPENROUTER_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(OPENROUTER_API_KEY),\n                \"Content-Type\": \"application/json\",\n                \"HTTP-Referer\": window.location.origin,\n                \"X-Title\": \"Product Image Modifier\"\n            },\n            body: JSON.stringify({\n                model: \"openai/gpt-4o\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: 'Analyze this product image in extreme detail. This image may contain text in ANY language (Chinese, Russian, English, etc.) and may have complex layouts with information panels.\\n\\n1. IMAGE LAYOUT:\\n   - Describe the overall layout (product photo only, or product + information panel)\\n   - If there\\'s an information panel (left/right/top/bottom), note its position and color\\n   - Note exact image dimensions\\n\\n2. PRODUCT PHYSICAL DETAILS (most important):\\n   - Exact product type (vacuum cleaner, bottle, box, appliance, etc.)\\n   - Precise shape and form\\n   - Material appearance (plastic, metal, glass, stainless steel, etc.)\\n   - Colors and design elements\\n   - Size and proportions\\n\\n3. ALL TEXT IN IMAGE (CRITICAL - in ANY language):\\n   ⚠️ IMPORTANT: Identify and list ALL text, regardless of language (Chinese, Russian, English, etc.)\\n   \\n   Categorize each text element as:\\n   A) BRAND NAME/LOGO: Company names, brand logos, trademark symbols\\n      Examples: \"Nike\", \"Adidas\", \"Янцзы\" (brand name)\\n   \\n   B) PRODUCT FEATURES/SELLING POINTS: All descriptive text about the product\\n      Examples: \"防水\" (waterproof), \"1500W большая мощность\" (1500W high power)\\n      \"18L емкость\" (18L capacity), \"Нержавеющая сталь\" (stainless steel)\\n   \\n   C) SPECIFICATIONS/INFO: Technical details, measurements, instructions\\n   \\n   For EACH text element, note:\\n   - The exact text (in original language)\\n   - Its category (A/B/C)\\n   - Its location on the image\\n   - Font size and style\\n\\n4. BACKGROUND:\\n   - Background type and colors\\n   - Lighting direction\\n\\nIMPORTANT: List ALL text visible in the image, preserving the original language. We need to distinguish brand names from product features.'\n                            },\n                            {\n                                type: \"image_url\",\n                                image_url: {\n                                    url: base64Image\n                                }\n                            }\n                        ]\n                    }\n                ],\n                max_tokens: 1200\n            })\n        });\n        if (!descriptionResponse.ok) {\n            var _errorData_error;\n            const errorData = await descriptionResponse.json();\n            throw new Error(\"图片分析失败: \".concat(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"未知错误\"));\n        }\n        const descriptionData = await descriptionResponse.json();\n        const description = (_descriptionData_choices = descriptionData.choices) === null || _descriptionData_choices === void 0 ? void 0 : (_descriptionData_choices_ = _descriptionData_choices[0]) === null || _descriptionData_choices_ === void 0 ? void 0 : (_descriptionData_choices__message = _descriptionData_choices_.message) === null || _descriptionData_choices__message === void 0 ? void 0 : _descriptionData_choices__message.content;\n        if (!description) {\n            throw new Error(\"未能获取图片描述\");\n        }\n        console.log(\"Step 2: Generating modified image for \".concat(fileName, \"...\"));\n        const modifiedPrompt = generateModificationPrompt(description, modificationLevel, logoText);\n        const numImages = 1;\n        const imageGenResponse = await fetch(OPENROUTER_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": \"Bearer \".concat(OPENROUTER_API_KEY),\n                \"Content-Type\": \"application/json\",\n                \"HTTP-Referer\": window.location.origin,\n                \"X-Title\": \"Product Image Modifier\"\n            },\n            body: JSON.stringify({\n                model: \"google/gemini-2.5-flash-preview-image\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: modifiedPrompt\n                            },\n                            {\n                                type: \"image_url\",\n                                image_url: {\n                                    url: base64Image\n                                }\n                            }\n                        ]\n                    }\n                ],\n                modalities: [\n                    \"image\",\n                    \"text\"\n                ],\n                max_tokens: 2048\n            })\n        });\n        if (!imageGenResponse.ok) {\n            const errorText = await imageGenResponse.text();\n            try {\n                var _errorData_error1;\n                const errorData = JSON.parse(errorText);\n                throw new Error(\"图片生成失败 (\".concat(imageGenResponse.status, \"): \").concat(((_errorData_error1 = errorData.error) === null || _errorData_error1 === void 0 ? void 0 : _errorData_error1.message) || errorText.substring(0, 200)));\n            } catch (e) {\n                throw new Error(\"图片生成失败 (\".concat(imageGenResponse.status, \"): \").concat(errorText.substring(0, 200)));\n            }\n        }\n        const imageGenData = await imageGenResponse.json();\n        const assistantMessage = (_imageGenData_choices = imageGenData.choices) === null || _imageGenData_choices === void 0 ? void 0 : (_imageGenData_choices_ = _imageGenData_choices[0]) === null || _imageGenData_choices_ === void 0 ? void 0 : _imageGenData_choices_.message;\n        let generatedImageUrl = null;\n        if ((assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.images) && Array.isArray(assistantMessage.images) && assistantMessage.images.length > 0) {\n            var _imageData_image_url;\n            const imageData = assistantMessage.images[0];\n            if (typeof imageData === \"string\") {\n                generatedImageUrl = imageData;\n            } else if ((_imageData_image_url = imageData.image_url) === null || _imageData_image_url === void 0 ? void 0 : _imageData_image_url.url) {\n                generatedImageUrl = imageData.image_url.url;\n            }\n        }\n        if (!generatedImageUrl && (assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content) && Array.isArray(assistantMessage.content)) {\n            for (const item of assistantMessage.content){\n                var _item_image_url;\n                if (item.type === \"image_url\" && ((_item_image_url = item.image_url) === null || _item_image_url === void 0 ? void 0 : _item_image_url.url)) {\n                    generatedImageUrl = item.image_url.url;\n                    break;\n                }\n            }\n        }\n        if (!generatedImageUrl) {\n            const content = assistantMessage === null || assistantMessage === void 0 ? void 0 : assistantMessage.content;\n            if (content && typeof content === \"string\") {\n                const urlMatch = content.match(/https?:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+\\.(jpg|jpeg|png|webp|gif)/i);\n                if (urlMatch) {\n                    generatedImageUrl = urlMatch[0];\n                }\n            }\n        }\n        if (!generatedImageUrl && imageGenData.data) {\n            var _imageGenData_data_;\n            if (Array.isArray(imageGenData.data) && ((_imageGenData_data_ = imageGenData.data[0]) === null || _imageGenData_data_ === void 0 ? void 0 : _imageGenData_data_.url)) {\n                generatedImageUrl = imageGenData.data[0].url;\n            } else if (typeof imageGenData.data === \"string\") {\n                generatedImageUrl = imageGenData.data;\n            }\n        }\n        if (!generatedImageUrl) {\n            throw new Error(\"未能生成图片 - API返回格式异常\");\n        }\n        const results = [];\n        const similarity = generateRandomSimilarity(modificationLevel);\n        const difference = 100 - similarity;\n        results.push({\n            url: generatedImageUrl,\n            originalUrl: base64Image,\n            similarity: similarity,\n            difference: difference\n        });\n        return results;\n    } catch (error) {\n        console.error(\"AI processing failed:\", error);\n        throw error;\n    }\n}\nfunction generateModificationPrompt(description, modificationLevel, logoText) {\n    let modifications = \"\";\n    if (modificationLevel <= 25) {\n        modifications = \"Subtle adjustments: slightly different lighting angle (keep shadows), minor color temperature shift in background only, subtle background blur or texture variation. Product appearance must be 95%+ identical.\";\n    } else if (modificationLevel <= 50) {\n        modifications = \"Moderate changes: different background color or pattern, adjusted lighting direction and intensity (affecting shadows only), different background style. Product packaging design, colors, and shape must remain 90%+ identical.\";\n    } else if (modificationLevel <= 75) {\n        modifications = \"Significant changes: completely new background setting or environment, dramatic lighting changes (affecting shadows and ambient light), new background theme, slightly adjusted camera angle (max 15 degrees). Product itself must remain 85%+ recognizable.\";\n    } else {\n        modifications = \"Major transformation: entirely different background scene, creative lighting setup, new artistic style for environment, varied composition perspective. Product physical appearance must remain 80%+ identical - same container, same design elements, same proportions.\";\n    }\n    const logoInstructions = logoText ? '\\n\\n5. TEXT HANDLING - MULTILINGUAL SUPPORT (CRITICAL):\\n   ⚠️ WORKS WITH ALL LANGUAGES: Chinese, Russian, English, etc.\\n   ⚠️ ONLY REMOVE BRAND IDENTITY - KEEP ALL SELLING POINTS!\\n\\n   STEP 1 - IDENTIFY TEXT TYPES (in ANY language):\\n   - Brand Identity: Company names, brand logos, trademark symbols\\n     * Chinese: \"Nike\", \"耐克\", \"Adidas\", \"阿迪达斯\"\\n     * Russian: \"Янцзы\" (brand name), company logos\\n     * English: \"Nike\", \"Apple\", brand emblems\\n\\n   - Selling Points: ALL product feature descriptions, specifications, benefits\\n     * Chinese: \"防水\", \"透气\", \"轻便\", \"5小时续航\"\\n     * Russian: \"Нержавеющая сталь\" (stainless steel), \"1500W большая мощность\" (1500W high power),\\n       \"18L емкость обновления\" (18L capacity), \"Многофункциональная модель\" (multifunctional model)\\n     * English: \"Waterproof\", \"Lightweight\", \"Fast Charging\", specifications\\n\\n   STEP 2 - SELECTIVE REMOVAL (ONLY brand identity):\\n   ✅ KEEP 100% of ALL selling point text in original language\\n   ✅ KEEP ALL product specifications and technical details\\n   ✅ KEEP ALL feature descriptions and benefits\\n   ✅ KEEP information panels (red/colored sidebars with product info)\\n   ❌ REMOVE ONLY brand names, company logos, trademark symbols\\n\\n   STEP 3 - ADD NEW LOGO:\\n   - ADD the text \"'.concat(logoText, '\" as NEW professional brand logo\\n   - Place where old brand logo was, or in prominent clean location\\n   - Logo styling:\\n     * Clean, professional font (sans-serif)\\n     * HIGH CONTRAST with background:\\n       - Light bg (>70%): DARK text (#000000, #333333)\\n       - Dark bg (<30%): WHITE text (#FFFFFF)\\n       - Medium bg: maximum contrast\\n     * Add subtle shadow/outline for visibility\\n\\n   EXAMPLES:\\n   Chinese: \"耐克 防水透气 轻便\" → \"').concat(logoText, ' 防水透气 轻便\"\\n   Russian: \"Янцзы Нержавеющая сталь\" → \"').concat(logoText, ' Нержавеющая сталь\"\\n\\n   ⚠️ CRITICAL: ALL selling points in ALL languages MUST remain 100% visible and readable!') : '\\n\\n5. TEXT HANDLING - MULTILINGUAL SUPPORT (CRITICAL):\\n   ⚠️ WORKS WITH ALL LANGUAGES: Chinese, Russian, English, etc.\\n   ⚠️ ONLY REMOVE BRAND IDENTITY - KEEP ALL SELLING POINTS!\\n\\n   STEP 1 - IDENTIFY TEXT TYPES (in ANY language):\\n   - Brand Identity: Company names, brand logos, trademark symbols\\n     * Chinese: \"Nike\", \"耐克\", \"Adidas\"\\n     * Russian: \"Янцзы\" (brand name)\\n     * English: \"Nike\", \"Apple\"\\n\\n   - Selling Points: ALL product feature descriptions\\n     * Chinese: \"防水\", \"透气\", \"轻便\"\\n     * Russian: \"Нержавеющая сталь\" (stainless steel), \"1500W большая мощность\" (1500W),\\n       \"18L емкость\" (18L capacity)\\n     * English: \"Waterproof\", \"Lightweight\"\\n\\n   STEP 2 - SELECTIVE REMOVAL (ONLY brand identity):\\n   ✅ KEEP 100% of ALL selling point text in original language\\n   ✅ KEEP ALL specifications and features\\n   ✅ KEEP information panels (colored sidebars)\\n   ❌ REMOVE ONLY brand names/logos\\n\\n   STEP 3 - RESULT:\\n   - Product looks unbranded (no company logos)\\n   - ALL selling points remain visible in original language\\n   - Information panels fully preserved\\n\\n   EXAMPLES:\\n   Chinese: \"耐克 防水透气\" → \"防水透气\"\\n   Russian: \"Янцзы Нержавеющая сталь\" → \"Нержавеющая сталь\"\\n\\n   ⚠️ CRITICAL: ALL selling points in ALL languages MUST remain 100% visible!';\n    const dimensionInstructions = \"\\n\\n6. IMAGE DIMENSIONS (CRITICAL):\\n   - Output image MUST maintain EXACTLY the same dimensions as input\\n   - Width and height must match the input image precisely\\n   - Do NOT crop, resize, or change aspect ratio\\n   - Preserve all edges and corners of the original image\";\n    const textColorInstructions = \"\\n\\n7. TEXT VISIBILITY - MULTILINGUAL (CRITICAL):\\n   - ALL text in ALL languages (Chinese/Russian/English/etc.) MUST be readable\\n   - Information panels (red/colored sidebars) MUST be preserved with all text\\n   - Text contrast rules:\\n     * White text + light background → change to dark OR add strong shadow/outline\\n     * Dark text + dark background → change to light OR add glow\\n     * Red/colored panels: preserve panel color, ensure text is readable\\n   - Text readability is MANDATORY for:\\n     * All selling points (any language)\\n     * All specifications and features\\n     * All information panel text\\n   - Adjust text colors intelligently based on new background\\n   - For complex layouts with panels: keep panel structure, adjust only background outside panels\";\n    return \"CRITICAL TASK: MINIMAL IMAGE EDITING - PRESERVE PRODUCT APPEARANCE\\n\\n⚠️ ABSOLUTE RULE: The product container/packaging/design MUST remain virtually IDENTICAL to the input image.\\n\\nApply ONLY these modifications: \".concat(modifications, \"\\n\\n=== CRITICAL REQUIREMENTS (FAILURE = REJECTED OUTPUT) ===\\n\\n1. PRODUCT PRESERVATION (HIGHEST PRIORITY):\\n   ❌ DO NOT redesign the product\\n   ❌ DO NOT change product colors significantly\\n   ❌ DO NOT alter product shape or proportions\\n   ❌ DO NOT modify packaging design elements (except logos/text removal)\\n   ❌ DO NOT change container type or material appearance\\n\\n   ✅ KEEP the exact same product container/bottle/box/package\\n   ✅ KEEP all design elements (patterns, graphics, color schemes)\\n   ✅ KEEP product dimensions and proportions\\n   ✅ KEEP material appearance (plastic, metal, glass, cardboard, etc.)\\n   ✅ KEEP ALL selling point text in ALL languages (Chinese, Russian, English, etc.)\\n   ✅ KEEP information panels (red/colored sidebars with product specifications)\\n   ✅ KEEP ALL product features, specifications, and technical details\\n   ✅ KEEP the exact same image dimensions (width x height)\\n   ✅ KEEP the overall layout structure (product photo + info panel if present)\\n   ✅ ONLY modify: background environment behind product, lighting/shadows, and remove ONLY brand logos/names\\n\\n2. WHAT YOU MAY CHANGE:\\n   - Background ONLY (color, pattern, environment, setting)\\n   - Lighting direction and intensity (affecting shadows/reflections ONLY)\\n   - Remove ONLY brand logos/company names (NOT selling points)\\n   - Add new brand logo if specified (cleanly, professionally placed)\\n   - Text colors for better visibility against new background\\n   - Camera angle slightly (max 15\\xb0 if modification level is high)\\n\\n3. WHAT YOU MUST NOT CHANGE:\\n   - Product's physical appearance (container shape, material, texture)\\n   - Product's color scheme and design graphics (except removing brand logos)\\n   - Product's size and proportions\\n   - Product's packaging style and design elements\\n   - Image dimensions (width x height)\\n   - Selling point text content in ANY language (features, benefits, specifications)\\n   - Product information text (ingredients, certifications, instructions)\\n   - Information panels structure and color (red/colored sidebars)\\n   - Panel text in original language (Russian, Chinese, English, etc.)\\n   - Overall product recognizability\\n   - Layout structure (don't merge panels into background or remove them)\\n\\n4. EDITING APPROACH:\\n   - Think: \\\"I'm using Photoshop to change the background behind this product\\\"\\n   - Think: \\\"The product is a physical object I cannot alter - I can only change its environment\\\"\\n   - For images with information panels: Keep the panel structure intact, only modify background behind/around the product\\n   - The output product should look like it's the SAME physical item photographed in a different setting\\n\\n5. SPECIAL HANDLING FOR COMPLEX LAYOUTS:\\n   - If image has information panel (red/colored sidebar with specs):\\n     * KEEP the panel with ALL its text in original language\\n     * KEEP panel colors and structure\\n     * Only modify the background behind the product photo area\\n     * Don't blend panel into background\\n   - Multi-language support:\\n     * Preserve ALL text in Russian (Нержавеющая сталь, емкость, etc.)\\n     * Preserve ALL text in Chinese (防水, 透气, etc.)\\n     * Preserve ALL text in English or any other language\\n     * Only remove brand names, keep all feature descriptions\\n\\n6. VERIFICATION CHECK (before output):\\n   ✓ Can I recognize this as the SAME product from the input?\\n   ✓ Did I only change the background/environment/lighting?\\n   ✓ Does the product container/packaging look virtually identical?\\n   ✓ Are ALL selling points in ALL languages still visible and readable?\\n   ✓ If there was an information panel, is it still there with all text?\\n   ✓ Would someone say \\\"same product, same layout, different background\\\"?\\n\\n\").concat(logoInstructions, \"\\n\").concat(dimensionInstructions, \"\\n\").concat(textColorInstructions, '\\n\\nReference description: \"').concat(description, '\"\\n\\n=== FINAL REMINDER ===\\nOUTPUT = Same product + Different background/lighting\\nNOT = New product inspired by the input\\n\\nThe person viewing the output should immediately recognize it as THE SAME PHYSICAL PRODUCT from the input image, just photographed in a different setting or lighting condition.');\n}\nfunction generateRandomSimilarity(modificationLevel) {\n    const baseSimilarity = 100 - modificationLevel;\n    const variance = 15;\n    const random = (Math.random() - 0.5) * variance;\n    return Math.max(30, Math.min(90, baseSimilarity + random));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbWFnZS1tb2RpZmllci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSxxQkFBcUI7QUFDM0IsTUFBTUMscUJBQXFCQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLDhCQUE4QjtBQVNyRSxlQUFlQyxxQkFBcUJDLFFBQWdCO0lBQ2xELElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTUMsV0FBVyxNQUFNQyxNQUFNSjtRQUM3QixJQUFJLENBQUNHLFNBQVNFLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sMEJBQTBDLE9BQWhCSCxTQUFTSSxNQUFNO1FBQzNEO1FBQ0EsTUFBTUMsT0FBTyxNQUFNTCxTQUFTSyxJQUFJO1FBQ2hDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixNQUFNQyxTQUFTLElBQUlDO1lBQ25CRCxPQUFPRSxTQUFTLEdBQUc7Z0JBQ2pCLE1BQU1DLFNBQVNILE9BQU9JLE1BQU07Z0JBQzVCZixRQUFRQyxHQUFHLENBQUMsc0NBQXNDYSxPQUFPRSxNQUFNO2dCQUMvRFAsUUFBUUs7WUFDVjtZQUNBSCxPQUFPTSxPQUFPLEdBQUdQO1lBQ2pCQyxPQUFPTyxhQUFhLENBQUNYO1FBQ3ZCO0lBQ0YsRUFBRSxPQUFPWSxPQUFPO1FBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLHNDQUFzQ0E7UUFDcEQsTUFBTUE7SUFDUjtBQUNGO0FBRU8sZUFBZUMsa0JBQ3BCckIsUUFBZ0IsRUFDaEJzQixpQkFBeUI7UUFDekJDLFdBQUFBLGlFQUFtQjtJQUVuQixPQUFPQyxrQkFBa0J4QixVQUFVc0IsbUJBQW1CQztBQUN4RDtBQUVPLGVBQWVFLHFCQUNwQkMsVUFBa0IsRUFDbEJKLGlCQUF5QjtRQUN6QkMsV0FBQUEsaUVBQW1CLElBQ25CSTtJQUVBLE1BQU1DLFVBQTJCLEVBQUU7SUFFbkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFdBQVdULE1BQU0sRUFBRVks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STtRQUNsQzhFLGdCQUFnQjtJQUNsQixPQUFPO1FBQ0xBLGdCQUFnQjtJQUNsQjtJQUVBLE1BQU1DLG1CQUFtQjlFLFdBQ3JCLDJ2Q0FtQ3dCQSxPQVhUQSxVQUFTLDhiQVlhQSxPQURiQSxVQUFTLHdEQUNhLE9BQVRBLFVBQVMsdUhBRzdDO0lBaUNMLE1BQU0rRSx3QkFBeUI7SUFNL0IsTUFBTUMsd0JBQXlCO0lBYy9CLE9BQU8seU5BeUVQRixPQXJFZ0NELGVBQWMsOHJIQXNFOUNFLE9BREFELGtCQUFpQixNQUVqQkUsT0FEQUQsdUJBQXNCLE1BR0UxQyxPQUZ4QjJDLHVCQUFzQixnQ0FFYyxPQUFaM0MsYUFBWTtBQU90QztBQUVBLFNBQVNvQyx5QkFBeUIxRSxpQkFBeUI7SUFDekQsTUFBTWtGLGlCQUFpQixNQUFNbEY7SUFDN0IsTUFBTW1GLFdBQVc7SUFDakIsTUFBTUMsU0FBUyxDQUFDeEMsS0FBS3dDLE1BQU0sS0FBSyxHQUFFLElBQUtEO0lBQ3ZDLE9BQU92QyxLQUFLRSxHQUFHLENBQUMsSUFBSUYsS0FBS0MsR0FBRyxDQUFDLElBQUlxQyxpQkFBaUJFO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9pbWFnZS1tb2RpZmllci50cz9lYjE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9QRU5ST1VURVJfQVBJX1VSTCA9IFwiaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zXCI7XG5jb25zdCBPUEVOUk9VVEVSX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOUk9VVEVSX0FQSV9LRVk7XG5cbmludGVyZmFjZSBNb2RpZmllZEltYWdlIHtcbiAgdXJsOiBzdHJpbmc7XG4gIG9yaWdpbmFsVXJsOiBzdHJpbmc7XG4gIHNpbWlsYXJpdHk6IG51bWJlcjtcbiAgZGlmZmVyZW5jZTogbnVtYmVyO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0SW1hZ2VUb0Jhc2U2NChpbWFnZVVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIkNvbnZlcnRpbmcgaW1hZ2UgdG8gYmFzZTY0Li4uXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW1hZ2VVcmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGltYWdlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkltYWdlIGNvbnZlcnRlZCB0byBiYXNlNjQsIGxlbmd0aDpcIiwgYmFzZTY0Lmxlbmd0aCk7XG4gICAgICAgIHJlc29sdmUoYmFzZTY0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCBpbWFnZSB0byBiYXNlNjQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbW9kaWZ5SW1hZ2VXaXRoQUkoXG4gIGltYWdlVXJsOiBzdHJpbmcsXG4gIG1vZGlmaWNhdGlvbkxldmVsOiBudW1iZXIsXG4gIGxvZ29UZXh0OiBzdHJpbmcgPSBcIlwiXG4pOiBQcm9taXNlPE1vZGlmaWVkSW1hZ2VbXT4ge1xuICByZXR1cm4gbW9kaWZ5U2luZ2xlSW1hZ2UoaW1hZ2VVcmwsIG1vZGlmaWNhdGlvbkxldmVsLCBsb2dvVGV4dCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtb2RpZnlNdWx0aXBsZUltYWdlcyhcbiAgaW1hZ2VGaWxlczogRmlsZVtdLFxuICBtb2RpZmljYXRpb25MZXZlbDogbnVtYmVyLFxuICBsb2dvVGV4dDogc3RyaW5nID0gXCJcIixcbiAgb25Qcm9ncmVzcz86IChjdXJyZW50OiBudW1iZXIsIHRvdGFsOiBudW1iZXIsIGN1cnJlbnRGaWxlOiBzdHJpbmcpID0+IHZvaWRcbik6IFByb21pc2U8TW9kaWZpZWRJbWFnZVtdPiB7XG4gIGNvbnN0IHJlc3VsdHM6IE1vZGlmaWVkSW1hZ2VbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpbGUgPSBpbWFnZUZpbGVzW2ldO1xuXG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgIG9uUHJvZ3Jlc3MoaSArIDEsIGltYWdlRmlsZXMubGVuZ3RoLCBmaWxlLm5hbWUpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlNjRJbWFnZSA9IGF3YWl0IGZpbGVUb0Jhc2U2NChmaWxlKTtcbiAgICAgIGNvbnN0IG1vZGlmaWVkSW1hZ2VzID0gYXdhaXQgbW9kaWZ5U2luZ2xlSW1hZ2VGcm9tQmFzZTY0KGJhc2U2NEltYWdlLCBtb2RpZmljYXRpb25MZXZlbCwgbG9nb1RleHQsIGZpbGUubmFtZSk7XG4gICAgICByZXN1bHRzLnB1c2goLi4ubW9kaWZpZWRJbWFnZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyAke2ZpbGUubmFtZX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGDlpITnkIblm77niYcgXCIke2ZpbGUubmFtZX1cIiDlpLHotKU6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAn5pyq55+l6ZSZ6K+vJ31gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gZmlsZVRvQmFzZTY0KGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtb2RpZnlTaW5nbGVJbWFnZShcbiAgaW1hZ2VVcmw6IHN0cmluZyxcbiAgbW9kaWZpY2F0aW9uTGV2ZWw6IG51bWJlcixcbiAgbG9nb1RleHQ6IHN0cmluZyA9IFwiXCJcbik6IFByb21pc2U8TW9kaWZpZWRJbWFnZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCJTdGVwIDE6IENvbnZlcnRpbmcgaW1hZ2UgdG8gYmFzZTY0Li4uXCIpO1xuICAgIGNvbnN0IGJhc2U2NEltYWdlID0gYXdhaXQgY29udmVydEltYWdlVG9CYXNlNjQoaW1hZ2VVcmwpO1xuXG4gICAgY29uc29sZS5sb2coXCJTdGVwIDI6IEFuYWx5emluZyBpbWFnZSB3aXRoIEdQVC00by4uLlwiKTtcblxuICAgIGNvbnN0IGRlc2NyaXB0aW9uUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChPUEVOUk9VVEVSX0FQSV9VUkwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7T1BFTlJPVVRFUl9BUElfS0VZfWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkhUVFAtUmVmZXJlclwiOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICBcIlgtVGl0bGVcIjogXCJQcm9kdWN0IEltYWdlIE1vZGlmaWVyXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtb2RlbDogXCJvcGVuYWkvZ3B0LTRvXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIkFuYWx5emUgdGhpcyBwcm9kdWN0IGltYWdlIGluIGV4dHJlbWUgZGV0YWlsLiBUaGlzIGltYWdlIG1heSBjb250YWluIHRleHQgaW4gQU5ZIGxhbmd1YWdlIChDaGluZXNlLCBSdXNzaWFuLCBFbmdsaXNoLCBldGMuKSBhbmQgbWF5IGhhdmUgY29tcGxleCBsYXlvdXRzIHdpdGggaW5mb3JtYXRpb24gcGFuZWxzLlxcblxcbjEuIElNQUdFIExBWU9VVDpcXG4gICAtIERlc2NyaWJlIHRoZSBvdmVyYWxsIGxheW91dCAocHJvZHVjdCBwaG90byBvbmx5LCBvciBwcm9kdWN0ICsgaW5mb3JtYXRpb24gcGFuZWwpXFxuICAgLSBJZiB0aGVyZSdzIGFuIGluZm9ybWF0aW9uIHBhbmVsIChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20pLCBub3RlIGl0cyBwb3NpdGlvbiBhbmQgY29sb3JcXG4gICAtIE5vdGUgZXhhY3QgaW1hZ2UgZGltZW5zaW9uc1xcblxcbjIuIFBST0RVQ1QgUEhZU0lDQUwgREVUQUlMUyAobW9zdCBpbXBvcnRhbnQpOlxcbiAgIC0gRXhhY3QgcHJvZHVjdCB0eXBlICh2YWN1dW0gY2xlYW5lciwgYm90dGxlLCBib3gsIGFwcGxpYW5jZSwgZXRjLilcXG4gICAtIFByZWNpc2Ugc2hhcGUgYW5kIGZvcm1cXG4gICAtIE1hdGVyaWFsIGFwcGVhcmFuY2UgKHBsYXN0aWMsIG1ldGFsLCBnbGFzcywgc3RhaW5sZXNzIHN0ZWVsLCBldGMuKVxcbiAgIC0gQ29sb3JzIGFuZCBkZXNpZ24gZWxlbWVudHNcXG4gICAtIFNpemUgYW5kIHByb3BvcnRpb25zXFxuXFxuMy4gQUxMIFRFWFQgSU4gSU1BR0UgKENSSVRJQ0FMIC0gaW4gQU5ZIGxhbmd1YWdlKTpcXG4gICDimqDvuI8gSU1QT1JUQU5UOiBJZGVudGlmeSBhbmQgbGlzdCBBTEwgdGV4dCwgcmVnYXJkbGVzcyBvZiBsYW5ndWFnZSAoQ2hpbmVzZSwgUnVzc2lhbiwgRW5nbGlzaCwgZXRjLilcXG4gICBcXG4gICBDYXRlZ29yaXplIGVhY2ggdGV4dCBlbGVtZW50IGFzOlxcbiAgIEEpIEJSQU5EIE5BTUUvTE9HTzogQ29tcGFueSBuYW1lcywgYnJhbmQgbG9nb3MsIHRyYWRlbWFyayBzeW1ib2xzXFxuICAgICAgRXhhbXBsZXM6IFxcXCJOaWtlXFxcIiwgXFxcIkFkaWRhc1xcXCIsIFxcXCLQr9C90YbQt9GLXFxcIiAoYnJhbmQgbmFtZSlcXG4gICBcXG4gICBCKSBQUk9EVUNUIEZFQVRVUkVTL1NFTExJTkcgUE9JTlRTOiBBbGwgZGVzY3JpcHRpdmUgdGV4dCBhYm91dCB0aGUgcHJvZHVjdFxcbiAgICAgIEV4YW1wbGVzOiBcXFwi6Ziy5rC0XFxcIiAod2F0ZXJwcm9vZiksIFxcXCIxNTAwVyDQsdC+0LvRjNGI0LDRjyDQvNC+0YnQvdC+0YHRgtGMXFxcIiAoMTUwMFcgaGlnaCBwb3dlcilcXG4gICAgICBcXFwiMThMINC10LzQutC+0YHRgtGMXFxcIiAoMThMIGNhcGFjaXR5KSwgXFxcItCd0LXRgNC20LDQstC10Y7RidCw0Y8g0YHRgtCw0LvRjFxcXCIgKHN0YWlubGVzcyBzdGVlbClcXG4gICBcXG4gICBDKSBTUEVDSUZJQ0FUSU9OUy9JTkZPOiBUZWNobmljYWwgZGV0YWlscywgbWVhc3VyZW1lbnRzLCBpbnN0cnVjdGlvbnNcXG4gICBcXG4gICBGb3IgRUFDSCB0ZXh0IGVsZW1lbnQsIG5vdGU6XFxuICAgLSBUaGUgZXhhY3QgdGV4dCAoaW4gb3JpZ2luYWwgbGFuZ3VhZ2UpXFxuICAgLSBJdHMgY2F0ZWdvcnkgKEEvQi9DKVxcbiAgIC0gSXRzIGxvY2F0aW9uIG9uIHRoZSBpbWFnZVxcbiAgIC0gRm9udCBzaXplIGFuZCBzdHlsZVxcblxcbjQuIEJBQ0tHUk9VTkQ6XFxuICAgLSBCYWNrZ3JvdW5kIHR5cGUgYW5kIGNvbG9yc1xcbiAgIC0gTGlnaHRpbmcgZGlyZWN0aW9uXFxuXFxuSU1QT1JUQU5UOiBMaXN0IEFMTCB0ZXh0IHZpc2libGUgaW4gdGhlIGltYWdlLCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBsYW5ndWFnZS4gV2UgbmVlZCB0byBkaXN0aW5ndWlzaCBicmFuZCBuYW1lcyBmcm9tIHByb2R1Y3QgZmVhdHVyZXMuXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDogeyB1cmw6IGJhc2U2NEltYWdlIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG1heF90b2tlbnM6IDEyMDAsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghZGVzY3JpcHRpb25SZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgZGVzY3JpcHRpb25SZXNwb25zZS5qc29uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYOWbvueJh+WIhuaekOWksei0pTogJHtlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgJ+acquefpemUmeivryd9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRpb25EYXRhID0gYXdhaXQgZGVzY3JpcHRpb25SZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbkRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50O1xuXG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5pyq6IO96I635Y+W5Zu+54mH5o+P6L+wXCIpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgZGVzY3JpcHRpb246XCIsIGRlc2NyaXB0aW9uLnN1YnN0cmluZygwLCAxMDApICsgXCIuLi5cIik7XG4gICAgY29uc29sZS5sb2coXCJTdGVwIDM6IEdlbmVyYXRpbmcgbW9kaWZpZWQgaW1hZ2Ugd2l0aCBHZW1pbmkuLi5cIik7XG5cbiAgICBjb25zdCBtb2RpZmllZFByb21wdCA9IGdlbmVyYXRlTW9kaWZpY2F0aW9uUHJvbXB0KGRlc2NyaXB0aW9uLCBtb2RpZmljYXRpb25MZXZlbCwgbG9nb1RleHQpO1xuICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGVkIHByb21wdDpcIiwgbW9kaWZpZWRQcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCkgKyBcIi4uLlwiKTtcblxuICAgIGNvbnN0IG51bUltYWdlcyA9IE1hdGgubWluKDMsIE1hdGgubWF4KDEsIE1hdGguZmxvb3IobW9kaWZpY2F0aW9uTGV2ZWwgLyAzMCkpKTtcblxuICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyBpbWFnZSBnZW5lcmF0aW9uIHJlcXVlc3Qgd2l0aCBtb2RlbDogZ29vZ2xlL2dlbWluaS0yLjUtZmxhc2gtcHJldmlldy1pbWFnZVwiKTtcblxuICAgIGNvbnN0IGltYWdlR2VuUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChPUEVOUk9VVEVSX0FQSV9VUkwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7T1BFTlJPVVRFUl9BUElfS0VZfWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkhUVFAtUmVmZXJlclwiOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICBcIlgtVGl0bGVcIjogXCJQcm9kdWN0IEltYWdlIE1vZGlmaWVyXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtb2RlbDogXCJnb29nbGUvZ2VtaW5pLTIuNS1mbGFzaC1wcmV2aWV3LWltYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBtb2RpZmllZFByb21wdCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiB7IHVybDogYmFzZTY0SW1hZ2UgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbW9kYWxpdGllczogW1wiaW1hZ2VcIiwgXCJ0ZXh0XCJdLFxuICAgICAgICBtYXhfdG9rZW5zOiAyMDQ4LFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkltYWdlIGdlbmVyYXRpb24gcmVzcG9uc2Ugc3RhdHVzOlwiLCBpbWFnZUdlblJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICBpZiAoIWltYWdlR2VuUmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IGltYWdlR2VuUmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkltYWdlIGdlbmVyYXRpb24gZmFpbGVkLiBTdGF0dXM6XCIsIGltYWdlR2VuUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXNwb25zZTpcIiwgZXJyb3JUZXh0KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYOWbvueJh+eUn+aIkOWksei0pSAoJHtpbWFnZUdlblJlc3BvbnNlLnN0YXR1c30pOiAke2Vycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvclRleHQuc3Vic3RyaW5nKDAsIDIwMCl9YCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihg5Zu+54mH55Sf5oiQ5aSx6LSlICgke2ltYWdlR2VuUmVzcG9uc2Uuc3RhdHVzfSk6ICR7ZXJyb3JUZXh0LnN1YnN0cmluZygwLCAyMDApfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGltYWdlR2VuRGF0YSA9IGF3YWl0IGltYWdlR2VuUmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgZ2VuZXJhdGlvbiByZXNwb25zZSBrZXlzOlwiLCBPYmplY3Qua2V5cyhpbWFnZUdlbkRhdGEpKTtcbiAgICBjb25zb2xlLmxvZyhcIkZ1bGwgaW1hZ2UgZ2VuZXJhdGlvbiByZXNwb25zZTpcIiwgSlNPTi5zdHJpbmdpZnkoaW1hZ2VHZW5EYXRhLCBudWxsLCAyKS5zdWJzdHJpbmcoMCwgMTAwMCkpO1xuXG4gICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGltYWdlR2VuRGF0YS5jaG9pY2VzPy5bMF0/Lm1lc3NhZ2U7XG4gICAgY29uc29sZS5sb2coXCJBc3Npc3RhbnQgbWVzc2FnZTpcIiwgYXNzaXN0YW50TWVzc2FnZSk7XG5cbiAgICBsZXQgZ2VuZXJhdGVkSW1hZ2VVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgLy8gTWV0aG9kIDE6IENoZWNrIGZvciBpbWFnZXMgYXJyYXkgaW4gbWVzc2FnZVxuICAgIGlmIChhc3Npc3RhbnRNZXNzYWdlPy5pbWFnZXMgJiYgQXJyYXkuaXNBcnJheShhc3Npc3RhbnRNZXNzYWdlLmltYWdlcykgJiYgYXNzaXN0YW50TWVzc2FnZS5pbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBpbWFnZXMgYXJyYXk6XCIsIGFzc2lzdGFudE1lc3NhZ2UuaW1hZ2VzKTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGFzc2lzdGFudE1lc3NhZ2UuaW1hZ2VzWzBdO1xuXG4gICAgICBpZiAodHlwZW9mIGltYWdlRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2VuZXJhdGVkSW1hZ2VVcmwgPSBpbWFnZURhdGE7XG4gICAgICB9IGVsc2UgaWYgKGltYWdlRGF0YS5pbWFnZV91cmw/LnVybCkge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVybCA9IGltYWdlRGF0YS5pbWFnZV91cmwudXJsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ldGhvZCAyOiBDaGVjayBjb250ZW50IGFycmF5IGZvciBpbWFnZV91cmwgdHlwZVxuICAgIGlmICghZ2VuZXJhdGVkSW1hZ2VVcmwgJiYgYXNzaXN0YW50TWVzc2FnZT8uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGFzc2lzdGFudE1lc3NhZ2UuY29udGVudCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tpbmcgY29udGVudCBhcnJheTpcIiwgYXNzaXN0YW50TWVzc2FnZS5jb250ZW50KTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhc3Npc3RhbnRNZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2ltYWdlX3VybCcgJiYgaXRlbS5pbWFnZV91cmw/LnVybCkge1xuICAgICAgICAgIGdlbmVyYXRlZEltYWdlVXJsID0gaXRlbS5pbWFnZV91cmwudXJsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kIDM6IENoZWNrIGZvciBVUkwgaW4gdGV4dCBjb250ZW50XG4gICAgaWYgKCFnZW5lcmF0ZWRJbWFnZVVybCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lzdGFudE1lc3NhZ2U/LmNvbnRlbnQ7XG4gICAgICBpZiAoY29udGVudCAmJiB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDaGVja2luZyBzdHJpbmcgY29udGVudCBmb3IgVVJMc1wiKTtcbiAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9odHRwcz86XFwvXFwvW15cXHM8Plwie318XFxcXF5gXFxbXFxdXStcXC4oanBnfGpwZWd8cG5nfHdlYnB8Z2lmKS9pKTtcbiAgICAgICAgaWYgKHVybE1hdGNoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VVcmwgPSB1cmxNYXRjaFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ldGhvZCA0OiBDaGVjayB0b3AtbGV2ZWwgZGF0YSBmaWVsZFxuICAgIGlmICghZ2VuZXJhdGVkSW1hZ2VVcmwgJiYgaW1hZ2VHZW5EYXRhLmRhdGEpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tpbmcgdG9wLWxldmVsIGRhdGEgZmllbGQ6XCIsIGltYWdlR2VuRGF0YS5kYXRhKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGltYWdlR2VuRGF0YS5kYXRhKSAmJiBpbWFnZUdlbkRhdGEuZGF0YVswXT8udXJsKSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlVXJsID0gaW1hZ2VHZW5EYXRhLmRhdGFbMF0udXJsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW1hZ2VHZW5EYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlVXJsID0gaW1hZ2VHZW5EYXRhLmRhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnZW5lcmF0ZWRJbWFnZVVybCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBleHRyYWN0IGltYWdlIFVSTC4gUmVzcG9uc2Ugc3RydWN0dXJlOlwiLCB7XG4gICAgICAgIGhhc0Nob2ljZXM6ICEhaW1hZ2VHZW5EYXRhLmNob2ljZXMsXG4gICAgICAgIGNob2ljZXNMZW5ndGg6IGltYWdlR2VuRGF0YS5jaG9pY2VzPy5sZW5ndGgsXG4gICAgICAgIGhhc01lc3NhZ2U6ICEhYXNzaXN0YW50TWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUtleXM6IGFzc2lzdGFudE1lc3NhZ2UgPyBPYmplY3Qua2V5cyhhc3Npc3RhbnRNZXNzYWdlKSA6IFtdLFxuICAgICAgICBtZXNzYWdlQ29udGVudFR5cGU6IHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlPy5jb250ZW50LFxuICAgICAgICBpc0NvbnRlbnRBcnJheTogQXJyYXkuaXNBcnJheShhc3Npc3RhbnRNZXNzYWdlPy5jb250ZW50KSxcbiAgICAgICAgdG9wTGV2ZWxLZXlzOiBPYmplY3Qua2V5cyhpbWFnZUdlbkRhdGEpLFxuICAgICAgICBmdWxsUmVzcG9uc2U6IEpTT04uc3RyaW5naWZ5KGltYWdlR2VuRGF0YSkuc3Vic3RyaW5nKDAsIDUwMClcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5pyq6IO955Sf5oiQ5Zu+54mHIC0gQVBJ6L+U5Zue5qC85byP5byC5bi444CC6K+35p+l55yL5rWP6KeI5Zmo5o6n5Yi25Y+w5LqG6Kej6K+m5oOFXCIpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCBpbWFnZVwiKTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IE1vZGlmaWVkSW1hZ2VbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbWFnZXM7IGkrKykge1xuICAgICAgY29uc3Qgc2ltaWxhcml0eSA9IGdlbmVyYXRlUmFuZG9tU2ltaWxhcml0eShtb2RpZmljYXRpb25MZXZlbCk7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlID0gMTAwIC0gc2ltaWxhcml0eTtcblxuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgdXJsOiBnZW5lcmF0ZWRJbWFnZVVybCxcbiAgICAgICAgb3JpZ2luYWxVcmw6IGltYWdlVXJsLFxuICAgICAgICBzaW1pbGFyaXR5OiBzaW1pbGFyaXR5LFxuICAgICAgICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkFJIHByb2Nlc3NpbmcgZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW9kaWZ5U2luZ2xlSW1hZ2VGcm9tQmFzZTY0KFxuICBiYXNlNjRJbWFnZTogc3RyaW5nLFxuICBtb2RpZmljYXRpb25MZXZlbDogbnVtYmVyLFxuICBsb2dvVGV4dDogc3RyaW5nID0gXCJcIixcbiAgZmlsZU5hbWU6IHN0cmluZyA9IFwiaW1hZ2VcIlxuKTogUHJvbWlzZTxNb2RpZmllZEltYWdlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgU3RlcCAxOiBBbmFseXppbmcgJHtmaWxlTmFtZX0gd2l0aCBHUFQtNG8uLi5gKTtcblxuICAgIGNvbnN0IGRlc2NyaXB0aW9uUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChPUEVOUk9VVEVSX0FQSV9VUkwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7T1BFTlJPVVRFUl9BUElfS0VZfWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkhUVFAtUmVmZXJlclwiOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICBcIlgtVGl0bGVcIjogXCJQcm9kdWN0IEltYWdlIE1vZGlmaWVyXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtb2RlbDogXCJvcGVuYWkvZ3B0LTRvXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIkFuYWx5emUgdGhpcyBwcm9kdWN0IGltYWdlIGluIGV4dHJlbWUgZGV0YWlsLiBUaGlzIGltYWdlIG1heSBjb250YWluIHRleHQgaW4gQU5ZIGxhbmd1YWdlIChDaGluZXNlLCBSdXNzaWFuLCBFbmdsaXNoLCBldGMuKSBhbmQgbWF5IGhhdmUgY29tcGxleCBsYXlvdXRzIHdpdGggaW5mb3JtYXRpb24gcGFuZWxzLlxcblxcbjEuIElNQUdFIExBWU9VVDpcXG4gICAtIERlc2NyaWJlIHRoZSBvdmVyYWxsIGxheW91dCAocHJvZHVjdCBwaG90byBvbmx5LCBvciBwcm9kdWN0ICsgaW5mb3JtYXRpb24gcGFuZWwpXFxuICAgLSBJZiB0aGVyZSdzIGFuIGluZm9ybWF0aW9uIHBhbmVsIChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20pLCBub3RlIGl0cyBwb3NpdGlvbiBhbmQgY29sb3JcXG4gICAtIE5vdGUgZXhhY3QgaW1hZ2UgZGltZW5zaW9uc1xcblxcbjIuIFBST0RVQ1QgUEhZU0lDQUwgREVUQUlMUyAobW9zdCBpbXBvcnRhbnQpOlxcbiAgIC0gRXhhY3QgcHJvZHVjdCB0eXBlICh2YWN1dW0gY2xlYW5lciwgYm90dGxlLCBib3gsIGFwcGxpYW5jZSwgZXRjLilcXG4gICAtIFByZWNpc2Ugc2hhcGUgYW5kIGZvcm1cXG4gICAtIE1hdGVyaWFsIGFwcGVhcmFuY2UgKHBsYXN0aWMsIG1ldGFsLCBnbGFzcywgc3RhaW5sZXNzIHN0ZWVsLCBldGMuKVxcbiAgIC0gQ29sb3JzIGFuZCBkZXNpZ24gZWxlbWVudHNcXG4gICAtIFNpemUgYW5kIHByb3BvcnRpb25zXFxuXFxuMy4gQUxMIFRFWFQgSU4gSU1BR0UgKENSSVRJQ0FMIC0gaW4gQU5ZIGxhbmd1YWdlKTpcXG4gICDimqDvuI8gSU1QT1JUQU5UOiBJZGVudGlmeSBhbmQgbGlzdCBBTEwgdGV4dCwgcmVnYXJkbGVzcyBvZiBsYW5ndWFnZSAoQ2hpbmVzZSwgUnVzc2lhbiwgRW5nbGlzaCwgZXRjLilcXG4gICBcXG4gICBDYXRlZ29yaXplIGVhY2ggdGV4dCBlbGVtZW50IGFzOlxcbiAgIEEpIEJSQU5EIE5BTUUvTE9HTzogQ29tcGFueSBuYW1lcywgYnJhbmQgbG9nb3MsIHRyYWRlbWFyayBzeW1ib2xzXFxuICAgICAgRXhhbXBsZXM6IFxcXCJOaWtlXFxcIiwgXFxcIkFkaWRhc1xcXCIsIFxcXCLQr9C90YbQt9GLXFxcIiAoYnJhbmQgbmFtZSlcXG4gICBcXG4gICBCKSBQUk9EVUNUIEZFQVRVUkVTL1NFTExJTkcgUE9JTlRTOiBBbGwgZGVzY3JpcHRpdmUgdGV4dCBhYm91dCB0aGUgcHJvZHVjdFxcbiAgICAgIEV4YW1wbGVzOiBcXFwi6Ziy5rC0XFxcIiAod2F0ZXJwcm9vZiksIFxcXCIxNTAwVyDQsdC+0LvRjNGI0LDRjyDQvNC+0YnQvdC+0YHRgtGMXFxcIiAoMTUwMFcgaGlnaCBwb3dlcilcXG4gICAgICBcXFwiMThMINC10LzQutC+0YHRgtGMXFxcIiAoMThMIGNhcGFjaXR5KSwgXFxcItCd0LXRgNC20LDQstC10Y7RidCw0Y8g0YHRgtCw0LvRjFxcXCIgKHN0YWlubGVzcyBzdGVlbClcXG4gICBcXG4gICBDKSBTUEVDSUZJQ0FUSU9OUy9JTkZPOiBUZWNobmljYWwgZGV0YWlscywgbWVhc3VyZW1lbnRzLCBpbnN0cnVjdGlvbnNcXG4gICBcXG4gICBGb3IgRUFDSCB0ZXh0IGVsZW1lbnQsIG5vdGU6XFxuICAgLSBUaGUgZXhhY3QgdGV4dCAoaW4gb3JpZ2luYWwgbGFuZ3VhZ2UpXFxuICAgLSBJdHMgY2F0ZWdvcnkgKEEvQi9DKVxcbiAgIC0gSXRzIGxvY2F0aW9uIG9uIHRoZSBpbWFnZVxcbiAgIC0gRm9udCBzaXplIGFuZCBzdHlsZVxcblxcbjQuIEJBQ0tHUk9VTkQ6XFxuICAgLSBCYWNrZ3JvdW5kIHR5cGUgYW5kIGNvbG9yc1xcbiAgIC0gTGlnaHRpbmcgZGlyZWN0aW9uXFxuXFxuSU1QT1JUQU5UOiBMaXN0IEFMTCB0ZXh0IHZpc2libGUgaW4gdGhlIGltYWdlLCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBsYW5ndWFnZS4gV2UgbmVlZCB0byBkaXN0aW5ndWlzaCBicmFuZCBuYW1lcyBmcm9tIHByb2R1Y3QgZmVhdHVyZXMuXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDogeyB1cmw6IGJhc2U2NEltYWdlIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG1heF90b2tlbnM6IDEyMDAsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghZGVzY3JpcHRpb25SZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgZGVzY3JpcHRpb25SZXNwb25zZS5qc29uKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYOWbvueJh+WIhuaekOWksei0pTogJHtlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgJ+acquefpemUmeivryd9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzY3JpcHRpb25EYXRhID0gYXdhaXQgZGVzY3JpcHRpb25SZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbkRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50O1xuXG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5pyq6IO96I635Y+W5Zu+54mH5o+P6L+wXCIpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBTdGVwIDI6IEdlbmVyYXRpbmcgbW9kaWZpZWQgaW1hZ2UgZm9yICR7ZmlsZU5hbWV9Li4uYCk7XG5cbiAgICBjb25zdCBtb2RpZmllZFByb21wdCA9IGdlbmVyYXRlTW9kaWZpY2F0aW9uUHJvbXB0KGRlc2NyaXB0aW9uLCBtb2RpZmljYXRpb25MZXZlbCwgbG9nb1RleHQpO1xuICAgIGNvbnN0IG51bUltYWdlcyA9IDE7XG5cbiAgICBjb25zdCBpbWFnZUdlblJlc3BvbnNlID0gYXdhaXQgZmV0Y2goT1BFTlJPVVRFUl9BUElfVVJMLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke09QRU5ST1VURVJfQVBJX0tFWX1gLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJIVFRQLVJlZmVyZXJcIjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgXCJYLVRpdGxlXCI6IFwiUHJvZHVjdCBJbWFnZSBNb2RpZmllclwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbW9kZWw6IFwiZ29vZ2xlL2dlbWluaS0yLjUtZmxhc2gtcHJldmlldy1pbWFnZVwiLFxuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogbW9kaWZpZWRQcm9tcHQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDogeyB1cmw6IGJhc2U2NEltYWdlIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG1vZGFsaXRpZXM6IFtcImltYWdlXCIsIFwidGV4dFwiXSxcbiAgICAgICAgbWF4X3Rva2VuczogMjA0OCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFpbWFnZUdlblJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCBpbWFnZUdlblJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDlm77niYfnlJ/miJDlpLHotKUgKCR7aW1hZ2VHZW5SZXNwb25zZS5zdGF0dXN9KTogJHtlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3JUZXh0LnN1YnN0cmluZygwLCAyMDApfWApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYOWbvueJh+eUn+aIkOWksei0pSAoJHtpbWFnZUdlblJlc3BvbnNlLnN0YXR1c30pOiAke2Vycm9yVGV4dC5zdWJzdHJpbmcoMCwgMjAwKX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZUdlbkRhdGEgPSBhd2FpdCBpbWFnZUdlblJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBhc3Npc3RhbnRNZXNzYWdlID0gaW1hZ2VHZW5EYXRhLmNob2ljZXM/LlswXT8ubWVzc2FnZTtcblxuICAgIGxldCBnZW5lcmF0ZWRJbWFnZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICBpZiAoYXNzaXN0YW50TWVzc2FnZT8uaW1hZ2VzICYmIEFycmF5LmlzQXJyYXkoYXNzaXN0YW50TWVzc2FnZS5pbWFnZXMpICYmIGFzc2lzdGFudE1lc3NhZ2UuaW1hZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGFzc2lzdGFudE1lc3NhZ2UuaW1hZ2VzWzBdO1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZURhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlVXJsID0gaW1hZ2VEYXRhO1xuICAgICAgfSBlbHNlIGlmIChpbWFnZURhdGEuaW1hZ2VfdXJsPy51cmwpIHtcbiAgICAgICAgZ2VuZXJhdGVkSW1hZ2VVcmwgPSBpbWFnZURhdGEuaW1hZ2VfdXJsLnVybDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdlbmVyYXRlZEltYWdlVXJsICYmIGFzc2lzdGFudE1lc3NhZ2U/LmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShhc3Npc3RhbnRNZXNzYWdlLmNvbnRlbnQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXNzaXN0YW50TWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdpbWFnZV91cmwnICYmIGl0ZW0uaW1hZ2VfdXJsPy51cmwpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRJbWFnZVVybCA9IGl0ZW0uaW1hZ2VfdXJsLnVybDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2VuZXJhdGVkSW1hZ2VVcmwpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhc3Npc3RhbnRNZXNzYWdlPy5jb250ZW50O1xuICAgICAgaWYgKGNvbnRlbnQgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybE1hdGNoID0gY29udGVudC5tYXRjaCgvaHR0cHM/OlxcL1xcL1teXFxzPD5cInt9fFxcXFxeYFxcW1xcXV0rXFwuKGpwZ3xqcGVnfHBuZ3x3ZWJwfGdpZikvaSk7XG4gICAgICAgIGlmICh1cmxNYXRjaCkge1xuICAgICAgICAgIGdlbmVyYXRlZEltYWdlVXJsID0gdXJsTWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdlbmVyYXRlZEltYWdlVXJsICYmIGltYWdlR2VuRGF0YS5kYXRhKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZUdlbkRhdGEuZGF0YSkgJiYgaW1hZ2VHZW5EYXRhLmRhdGFbMF0/LnVybCkge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVybCA9IGltYWdlR2VuRGF0YS5kYXRhWzBdLnVybDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGltYWdlR2VuRGF0YS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVybCA9IGltYWdlR2VuRGF0YS5kYXRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2VuZXJhdGVkSW1hZ2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIuacquiDveeUn+aIkOWbvueJhyAtIEFQSei/lOWbnuagvOW8j+W8guW4uFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzOiBNb2RpZmllZEltYWdlW10gPSBbXTtcbiAgICBjb25zdCBzaW1pbGFyaXR5ID0gZ2VuZXJhdGVSYW5kb21TaW1pbGFyaXR5KG1vZGlmaWNhdGlvbkxldmVsKTtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gMTAwIC0gc2ltaWxhcml0eTtcblxuICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICB1cmw6IGdlbmVyYXRlZEltYWdlVXJsLFxuICAgICAgb3JpZ2luYWxVcmw6IGJhc2U2NEltYWdlLFxuICAgICAgc2ltaWxhcml0eTogc2ltaWxhcml0eSxcbiAgICAgIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2UsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQUkgcHJvY2Vzc2luZyBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1vZGlmaWNhdGlvblByb21wdChkZXNjcmlwdGlvbjogc3RyaW5nLCBtb2RpZmljYXRpb25MZXZlbDogbnVtYmVyLCBsb2dvVGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IG1vZGlmaWNhdGlvbnMgPSAnJztcblxuICBpZiAobW9kaWZpY2F0aW9uTGV2ZWwgPD0gMjUpIHtcbiAgICBtb2RpZmljYXRpb25zID0gJ1N1YnRsZSBhZGp1c3RtZW50czogc2xpZ2h0bHkgZGlmZmVyZW50IGxpZ2h0aW5nIGFuZ2xlIChrZWVwIHNoYWRvd3MpLCBtaW5vciBjb2xvciB0ZW1wZXJhdHVyZSBzaGlmdCBpbiBiYWNrZ3JvdW5kIG9ubHksIHN1YnRsZSBiYWNrZ3JvdW5kIGJsdXIgb3IgdGV4dHVyZSB2YXJpYXRpb24uIFByb2R1Y3QgYXBwZWFyYW5jZSBtdXN0IGJlIDk1JSsgaWRlbnRpY2FsLic7XG4gIH0gZWxzZSBpZiAobW9kaWZpY2F0aW9uTGV2ZWwgPD0gNTApIHtcbiAgICBtb2RpZmljYXRpb25zID0gJ01vZGVyYXRlIGNoYW5nZXM6IGRpZmZlcmVudCBiYWNrZ3JvdW5kIGNvbG9yIG9yIHBhdHRlcm4sIGFkanVzdGVkIGxpZ2h0aW5nIGRpcmVjdGlvbiBhbmQgaW50ZW5zaXR5IChhZmZlY3Rpbmcgc2hhZG93cyBvbmx5KSwgZGlmZmVyZW50IGJhY2tncm91bmQgc3R5bGUuIFByb2R1Y3QgcGFja2FnaW5nIGRlc2lnbiwgY29sb3JzLCBhbmQgc2hhcGUgbXVzdCByZW1haW4gOTAlKyBpZGVudGljYWwuJztcbiAgfSBlbHNlIGlmIChtb2RpZmljYXRpb25MZXZlbCA8PSA3NSkge1xuICAgIG1vZGlmaWNhdGlvbnMgPSAnU2lnbmlmaWNhbnQgY2hhbmdlczogY29tcGxldGVseSBuZXcgYmFja2dyb3VuZCBzZXR0aW5nIG9yIGVudmlyb25tZW50LCBkcmFtYXRpYyBsaWdodGluZyBjaGFuZ2VzIChhZmZlY3Rpbmcgc2hhZG93cyBhbmQgYW1iaWVudCBsaWdodCksIG5ldyBiYWNrZ3JvdW5kIHRoZW1lLCBzbGlnaHRseSBhZGp1c3RlZCBjYW1lcmEgYW5nbGUgKG1heCAxNSBkZWdyZWVzKS4gUHJvZHVjdCBpdHNlbGYgbXVzdCByZW1haW4gODUlKyByZWNvZ25pemFibGUuJztcbiAgfSBlbHNlIHtcbiAgICBtb2RpZmljYXRpb25zID0gJ01ham9yIHRyYW5zZm9ybWF0aW9uOiBlbnRpcmVseSBkaWZmZXJlbnQgYmFja2dyb3VuZCBzY2VuZSwgY3JlYXRpdmUgbGlnaHRpbmcgc2V0dXAsIG5ldyBhcnRpc3RpYyBzdHlsZSBmb3IgZW52aXJvbm1lbnQsIHZhcmllZCBjb21wb3NpdGlvbiBwZXJzcGVjdGl2ZS4gUHJvZHVjdCBwaHlzaWNhbCBhcHBlYXJhbmNlIG11c3QgcmVtYWluIDgwJSsgaWRlbnRpY2FsIC0gc2FtZSBjb250YWluZXIsIHNhbWUgZGVzaWduIGVsZW1lbnRzLCBzYW1lIHByb3BvcnRpb25zLic7XG4gIH1cblxuICBjb25zdCBsb2dvSW5zdHJ1Y3Rpb25zID0gbG9nb1RleHRcbiAgICA/IGBcXG5cXG41LiBURVhUIEhBTkRMSU5HIC0gTVVMVElMSU5HVUFMIFNVUFBPUlQgKENSSVRJQ0FMKTpcbiAgIOKaoO+4jyBXT1JLUyBXSVRIIEFMTCBMQU5HVUFHRVM6IENoaW5lc2UsIFJ1c3NpYW4sIEVuZ2xpc2gsIGV0Yy5cbiAgIOKaoO+4jyBPTkxZIFJFTU9WRSBCUkFORCBJREVOVElUWSAtIEtFRVAgQUxMIFNFTExJTkcgUE9JTlRTIVxuXG4gICBTVEVQIDEgLSBJREVOVElGWSBURVhUIFRZUEVTIChpbiBBTlkgbGFuZ3VhZ2UpOlxuICAgLSBCcmFuZCBJZGVudGl0eTogQ29tcGFueSBuYW1lcywgYnJhbmQgbG9nb3MsIHRyYWRlbWFyayBzeW1ib2xzXG4gICAgICogQ2hpbmVzZTogXCJOaWtlXCIsIFwi6ICQ5YWLXCIsIFwiQWRpZGFzXCIsIFwi6Zi/6L+q6L6+5pavXCJcbiAgICAgKiBSdXNzaWFuOiBcItCv0L3RhtC30YtcIiAoYnJhbmQgbmFtZSksIGNvbXBhbnkgbG9nb3NcbiAgICAgKiBFbmdsaXNoOiBcIk5pa2VcIiwgXCJBcHBsZVwiLCBicmFuZCBlbWJsZW1zXG5cbiAgIC0gU2VsbGluZyBQb2ludHM6IEFMTCBwcm9kdWN0IGZlYXR1cmUgZGVzY3JpcHRpb25zLCBzcGVjaWZpY2F0aW9ucywgYmVuZWZpdHNcbiAgICAgKiBDaGluZXNlOiBcIumYsuawtFwiLCBcIumAj+awlFwiLCBcIui9u+S+v1wiLCBcIjXlsI/ml7bnu63oiKpcIlxuICAgICAqIFJ1c3NpYW46IFwi0J3QtdGA0LbQsNCy0LXRjtGJ0LDRjyDRgdGC0LDQu9GMXCIgKHN0YWlubGVzcyBzdGVlbCksIFwiMTUwMFcg0LHQvtC70YzRiNCw0Y8g0LzQvtGJ0L3QvtGB0YLRjFwiICgxNTAwVyBoaWdoIHBvd2VyKSxcbiAgICAgICBcIjE4TCDQtdC80LrQvtGB0YLRjCDQvtCx0L3QvtCy0LvQtdC90LjRj1wiICgxOEwgY2FwYWNpdHkpLCBcItCc0L3QvtCz0L7RhNGD0L3QutGG0LjQvtC90LDQu9GM0L3QsNGPINC80L7QtNC10LvRjFwiIChtdWx0aWZ1bmN0aW9uYWwgbW9kZWwpXG4gICAgICogRW5nbGlzaDogXCJXYXRlcnByb29mXCIsIFwiTGlnaHR3ZWlnaHRcIiwgXCJGYXN0IENoYXJnaW5nXCIsIHNwZWNpZmljYXRpb25zXG5cbiAgIFNURVAgMiAtIFNFTEVDVElWRSBSRU1PVkFMIChPTkxZIGJyYW5kIGlkZW50aXR5KTpcbiAgIOKchSBLRUVQIDEwMCUgb2YgQUxMIHNlbGxpbmcgcG9pbnQgdGV4dCBpbiBvcmlnaW5hbCBsYW5ndWFnZVxuICAg4pyFIEtFRVAgQUxMIHByb2R1Y3Qgc3BlY2lmaWNhdGlvbnMgYW5kIHRlY2huaWNhbCBkZXRhaWxzXG4gICDinIUgS0VFUCBBTEwgZmVhdHVyZSBkZXNjcmlwdGlvbnMgYW5kIGJlbmVmaXRzXG4gICDinIUgS0VFUCBpbmZvcm1hdGlvbiBwYW5lbHMgKHJlZC9jb2xvcmVkIHNpZGViYXJzIHdpdGggcHJvZHVjdCBpbmZvKVxuICAg4p2MIFJFTU9WRSBPTkxZIGJyYW5kIG5hbWVzLCBjb21wYW55IGxvZ29zLCB0cmFkZW1hcmsgc3ltYm9sc1xuXG4gICBTVEVQIDMgLSBBREQgTkVXIExPR086XG4gICAtIEFERCB0aGUgdGV4dCBcIiR7bG9nb1RleHR9XCIgYXMgTkVXIHByb2Zlc3Npb25hbCBicmFuZCBsb2dvXG4gICAtIFBsYWNlIHdoZXJlIG9sZCBicmFuZCBsb2dvIHdhcywgb3IgaW4gcHJvbWluZW50IGNsZWFuIGxvY2F0aW9uXG4gICAtIExvZ28gc3R5bGluZzpcbiAgICAgKiBDbGVhbiwgcHJvZmVzc2lvbmFsIGZvbnQgKHNhbnMtc2VyaWYpXG4gICAgICogSElHSCBDT05UUkFTVCB3aXRoIGJhY2tncm91bmQ6XG4gICAgICAgLSBMaWdodCBiZyAoPjcwJSk6IERBUksgdGV4dCAoIzAwMDAwMCwgIzMzMzMzMylcbiAgICAgICAtIERhcmsgYmcgKDwzMCUpOiBXSElURSB0ZXh0ICgjRkZGRkZGKVxuICAgICAgIC0gTWVkaXVtIGJnOiBtYXhpbXVtIGNvbnRyYXN0XG4gICAgICogQWRkIHN1YnRsZSBzaGFkb3cvb3V0bGluZSBmb3IgdmlzaWJpbGl0eVxuXG4gICBFWEFNUExFUzpcbiAgIENoaW5lc2U6IFwi6ICQ5YWLIOmYsuawtOmAj+awlCDovbvkvr9cIiDihpIgXCIke2xvZ29UZXh0fSDpmLLmsLTpgI/msJQg6L275L6/XCJcbiAgIFJ1c3NpYW46IFwi0K/QvdGG0LfRiyDQndC10YDQttCw0LLQtdGO0YnQsNGPINGB0YLQsNC70YxcIiDihpIgXCIke2xvZ29UZXh0fSDQndC10YDQttCw0LLQtdGO0YnQsNGPINGB0YLQsNC70YxcIlxuXG4gICDimqDvuI8gQ1JJVElDQUw6IEFMTCBzZWxsaW5nIHBvaW50cyBpbiBBTEwgbGFuZ3VhZ2VzIE1VU1QgcmVtYWluIDEwMCUgdmlzaWJsZSBhbmQgcmVhZGFibGUhYFxuICAgIDogYFxcblxcbjUuIFRFWFQgSEFORExJTkcgLSBNVUxUSUxJTkdVQUwgU1VQUE9SVCAoQ1JJVElDQUwpOlxuICAg4pqg77iPIFdPUktTIFdJVEggQUxMIExBTkdVQUdFUzogQ2hpbmVzZSwgUnVzc2lhbiwgRW5nbGlzaCwgZXRjLlxuICAg4pqg77iPIE9OTFkgUkVNT1ZFIEJSQU5EIElERU5USVRZIC0gS0VFUCBBTEwgU0VMTElORyBQT0lOVFMhXG5cbiAgIFNURVAgMSAtIElERU5USUZZIFRFWFQgVFlQRVMgKGluIEFOWSBsYW5ndWFnZSk6XG4gICAtIEJyYW5kIElkZW50aXR5OiBDb21wYW55IG5hbWVzLCBicmFuZCBsb2dvcywgdHJhZGVtYXJrIHN5bWJvbHNcbiAgICAgKiBDaGluZXNlOiBcIk5pa2VcIiwgXCLogJDlhYtcIiwgXCJBZGlkYXNcIlxuICAgICAqIFJ1c3NpYW46IFwi0K/QvdGG0LfRi1wiIChicmFuZCBuYW1lKVxuICAgICAqIEVuZ2xpc2g6IFwiTmlrZVwiLCBcIkFwcGxlXCJcblxuICAgLSBTZWxsaW5nIFBvaW50czogQUxMIHByb2R1Y3QgZmVhdHVyZSBkZXNjcmlwdGlvbnNcbiAgICAgKiBDaGluZXNlOiBcIumYsuawtFwiLCBcIumAj+awlFwiLCBcIui9u+S+v1wiXG4gICAgICogUnVzc2lhbjogXCLQndC10YDQttCw0LLQtdGO0YnQsNGPINGB0YLQsNC70YxcIiAoc3RhaW5sZXNzIHN0ZWVsKSwgXCIxNTAwVyDQsdC+0LvRjNGI0LDRjyDQvNC+0YnQvdC+0YHRgtGMXCIgKDE1MDBXKSxcbiAgICAgICBcIjE4TCDQtdC80LrQvtGB0YLRjFwiICgxOEwgY2FwYWNpdHkpXG4gICAgICogRW5nbGlzaDogXCJXYXRlcnByb29mXCIsIFwiTGlnaHR3ZWlnaHRcIlxuXG4gICBTVEVQIDIgLSBTRUxFQ1RJVkUgUkVNT1ZBTCAoT05MWSBicmFuZCBpZGVudGl0eSk6XG4gICDinIUgS0VFUCAxMDAlIG9mIEFMTCBzZWxsaW5nIHBvaW50IHRleHQgaW4gb3JpZ2luYWwgbGFuZ3VhZ2VcbiAgIOKchSBLRUVQIEFMTCBzcGVjaWZpY2F0aW9ucyBhbmQgZmVhdHVyZXNcbiAgIOKchSBLRUVQIGluZm9ybWF0aW9uIHBhbmVscyAoY29sb3JlZCBzaWRlYmFycylcbiAgIOKdjCBSRU1PVkUgT05MWSBicmFuZCBuYW1lcy9sb2dvc1xuXG4gICBTVEVQIDMgLSBSRVNVTFQ6XG4gICAtIFByb2R1Y3QgbG9va3MgdW5icmFuZGVkIChubyBjb21wYW55IGxvZ29zKVxuICAgLSBBTEwgc2VsbGluZyBwb2ludHMgcmVtYWluIHZpc2libGUgaW4gb3JpZ2luYWwgbGFuZ3VhZ2VcbiAgIC0gSW5mb3JtYXRpb24gcGFuZWxzIGZ1bGx5IHByZXNlcnZlZFxuXG4gICBFWEFNUExFUzpcbiAgIENoaW5lc2U6IFwi6ICQ5YWLIOmYsuawtOmAj+awlFwiIOKGkiBcIumYsuawtOmAj+awlFwiXG4gICBSdXNzaWFuOiBcItCv0L3RhtC30Ysg0J3QtdGA0LbQsNCy0LXRjtGJ0LDRjyDRgdGC0LDQu9GMXCIg4oaSIFwi0J3QtdGA0LbQsNCy0LXRjtGJ0LDRjyDRgdGC0LDQu9GMXCJcblxuICAg4pqg77iPIENSSVRJQ0FMOiBBTEwgc2VsbGluZyBwb2ludHMgaW4gQUxMIGxhbmd1YWdlcyBNVVNUIHJlbWFpbiAxMDAlIHZpc2libGUhYDtcblxuICBjb25zdCBkaW1lbnNpb25JbnN0cnVjdGlvbnMgPSBgXFxuXFxuNi4gSU1BR0UgRElNRU5TSU9OUyAoQ1JJVElDQUwpOlxuICAgLSBPdXRwdXQgaW1hZ2UgTVVTVCBtYWludGFpbiBFWEFDVExZIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgaW5wdXRcbiAgIC0gV2lkdGggYW5kIGhlaWdodCBtdXN0IG1hdGNoIHRoZSBpbnB1dCBpbWFnZSBwcmVjaXNlbHlcbiAgIC0gRG8gTk9UIGNyb3AsIHJlc2l6ZSwgb3IgY2hhbmdlIGFzcGVjdCByYXRpb1xuICAgLSBQcmVzZXJ2ZSBhbGwgZWRnZXMgYW5kIGNvcm5lcnMgb2YgdGhlIG9yaWdpbmFsIGltYWdlYDtcblxuICBjb25zdCB0ZXh0Q29sb3JJbnN0cnVjdGlvbnMgPSBgXFxuXFxuNy4gVEVYVCBWSVNJQklMSVRZIC0gTVVMVElMSU5HVUFMIChDUklUSUNBTCk6XG4gICAtIEFMTCB0ZXh0IGluIEFMTCBsYW5ndWFnZXMgKENoaW5lc2UvUnVzc2lhbi9FbmdsaXNoL2V0Yy4pIE1VU1QgYmUgcmVhZGFibGVcbiAgIC0gSW5mb3JtYXRpb24gcGFuZWxzIChyZWQvY29sb3JlZCBzaWRlYmFycykgTVVTVCBiZSBwcmVzZXJ2ZWQgd2l0aCBhbGwgdGV4dFxuICAgLSBUZXh0IGNvbnRyYXN0IHJ1bGVzOlxuICAgICAqIFdoaXRlIHRleHQgKyBsaWdodCBiYWNrZ3JvdW5kIOKGkiBjaGFuZ2UgdG8gZGFyayBPUiBhZGQgc3Ryb25nIHNoYWRvdy9vdXRsaW5lXG4gICAgICogRGFyayB0ZXh0ICsgZGFyayBiYWNrZ3JvdW5kIOKGkiBjaGFuZ2UgdG8gbGlnaHQgT1IgYWRkIGdsb3dcbiAgICAgKiBSZWQvY29sb3JlZCBwYW5lbHM6IHByZXNlcnZlIHBhbmVsIGNvbG9yLCBlbnN1cmUgdGV4dCBpcyByZWFkYWJsZVxuICAgLSBUZXh0IHJlYWRhYmlsaXR5IGlzIE1BTkRBVE9SWSBmb3I6XG4gICAgICogQWxsIHNlbGxpbmcgcG9pbnRzIChhbnkgbGFuZ3VhZ2UpXG4gICAgICogQWxsIHNwZWNpZmljYXRpb25zIGFuZCBmZWF0dXJlc1xuICAgICAqIEFsbCBpbmZvcm1hdGlvbiBwYW5lbCB0ZXh0XG4gICAtIEFkanVzdCB0ZXh0IGNvbG9ycyBpbnRlbGxpZ2VudGx5IGJhc2VkIG9uIG5ldyBiYWNrZ3JvdW5kXG4gICAtIEZvciBjb21wbGV4IGxheW91dHMgd2l0aCBwYW5lbHM6IGtlZXAgcGFuZWwgc3RydWN0dXJlLCBhZGp1c3Qgb25seSBiYWNrZ3JvdW5kIG91dHNpZGUgcGFuZWxzYDtcblxuICByZXR1cm4gYENSSVRJQ0FMIFRBU0s6IE1JTklNQUwgSU1BR0UgRURJVElORyAtIFBSRVNFUlZFIFBST0RVQ1QgQVBQRUFSQU5DRVxuXG7imqDvuI8gQUJTT0xVVEUgUlVMRTogVGhlIHByb2R1Y3QgY29udGFpbmVyL3BhY2thZ2luZy9kZXNpZ24gTVVTVCByZW1haW4gdmlydHVhbGx5IElERU5USUNBTCB0byB0aGUgaW5wdXQgaW1hZ2UuXG5cbkFwcGx5IE9OTFkgdGhlc2UgbW9kaWZpY2F0aW9uczogJHttb2RpZmljYXRpb25zfVxuXG49PT0gQ1JJVElDQUwgUkVRVUlSRU1FTlRTIChGQUlMVVJFID0gUkVKRUNURUQgT1VUUFVUKSA9PT1cblxuMS4gUFJPRFVDVCBQUkVTRVJWQVRJT04gKEhJR0hFU1QgUFJJT1JJVFkpOlxuICAg4p2MIERPIE5PVCByZWRlc2lnbiB0aGUgcHJvZHVjdFxuICAg4p2MIERPIE5PVCBjaGFuZ2UgcHJvZHVjdCBjb2xvcnMgc2lnbmlmaWNhbnRseVxuICAg4p2MIERPIE5PVCBhbHRlciBwcm9kdWN0IHNoYXBlIG9yIHByb3BvcnRpb25zXG4gICDinYwgRE8gTk9UIG1vZGlmeSBwYWNrYWdpbmcgZGVzaWduIGVsZW1lbnRzIChleGNlcHQgbG9nb3MvdGV4dCByZW1vdmFsKVxuICAg4p2MIERPIE5PVCBjaGFuZ2UgY29udGFpbmVyIHR5cGUgb3IgbWF0ZXJpYWwgYXBwZWFyYW5jZVxuXG4gICDinIUgS0VFUCB0aGUgZXhhY3Qgc2FtZSBwcm9kdWN0IGNvbnRhaW5lci9ib3R0bGUvYm94L3BhY2thZ2VcbiAgIOKchSBLRUVQIGFsbCBkZXNpZ24gZWxlbWVudHMgKHBhdHRlcm5zLCBncmFwaGljcywgY29sb3Igc2NoZW1lcylcbiAgIOKchSBLRUVQIHByb2R1Y3QgZGltZW5zaW9ucyBhbmQgcHJvcG9ydGlvbnNcbiAgIOKchSBLRUVQIG1hdGVyaWFsIGFwcGVhcmFuY2UgKHBsYXN0aWMsIG1ldGFsLCBnbGFzcywgY2FyZGJvYXJkLCBldGMuKVxuICAg4pyFIEtFRVAgQUxMIHNlbGxpbmcgcG9pbnQgdGV4dCBpbiBBTEwgbGFuZ3VhZ2VzIChDaGluZXNlLCBSdXNzaWFuLCBFbmdsaXNoLCBldGMuKVxuICAg4pyFIEtFRVAgaW5mb3JtYXRpb24gcGFuZWxzIChyZWQvY29sb3JlZCBzaWRlYmFycyB3aXRoIHByb2R1Y3Qgc3BlY2lmaWNhdGlvbnMpXG4gICDinIUgS0VFUCBBTEwgcHJvZHVjdCBmZWF0dXJlcywgc3BlY2lmaWNhdGlvbnMsIGFuZCB0ZWNobmljYWwgZGV0YWlsc1xuICAg4pyFIEtFRVAgdGhlIGV4YWN0IHNhbWUgaW1hZ2UgZGltZW5zaW9ucyAod2lkdGggeCBoZWlnaHQpXG4gICDinIUgS0VFUCB0aGUgb3ZlcmFsbCBsYXlvdXQgc3RydWN0dXJlIChwcm9kdWN0IHBob3RvICsgaW5mbyBwYW5lbCBpZiBwcmVzZW50KVxuICAg4pyFIE9OTFkgbW9kaWZ5OiBiYWNrZ3JvdW5kIGVudmlyb25tZW50IGJlaGluZCBwcm9kdWN0LCBsaWdodGluZy9zaGFkb3dzLCBhbmQgcmVtb3ZlIE9OTFkgYnJhbmQgbG9nb3MvbmFtZXNcblxuMi4gV0hBVCBZT1UgTUFZIENIQU5HRTpcbiAgIC0gQmFja2dyb3VuZCBPTkxZIChjb2xvciwgcGF0dGVybiwgZW52aXJvbm1lbnQsIHNldHRpbmcpXG4gICAtIExpZ2h0aW5nIGRpcmVjdGlvbiBhbmQgaW50ZW5zaXR5IChhZmZlY3Rpbmcgc2hhZG93cy9yZWZsZWN0aW9ucyBPTkxZKVxuICAgLSBSZW1vdmUgT05MWSBicmFuZCBsb2dvcy9jb21wYW55IG5hbWVzIChOT1Qgc2VsbGluZyBwb2ludHMpXG4gICAtIEFkZCBuZXcgYnJhbmQgbG9nbyBpZiBzcGVjaWZpZWQgKGNsZWFubHksIHByb2Zlc3Npb25hbGx5IHBsYWNlZClcbiAgIC0gVGV4dCBjb2xvcnMgZm9yIGJldHRlciB2aXNpYmlsaXR5IGFnYWluc3QgbmV3IGJhY2tncm91bmRcbiAgIC0gQ2FtZXJhIGFuZ2xlIHNsaWdodGx5IChtYXggMTXCsCBpZiBtb2RpZmljYXRpb24gbGV2ZWwgaXMgaGlnaClcblxuMy4gV0hBVCBZT1UgTVVTVCBOT1QgQ0hBTkdFOlxuICAgLSBQcm9kdWN0J3MgcGh5c2ljYWwgYXBwZWFyYW5jZSAoY29udGFpbmVyIHNoYXBlLCBtYXRlcmlhbCwgdGV4dHVyZSlcbiAgIC0gUHJvZHVjdCdzIGNvbG9yIHNjaGVtZSBhbmQgZGVzaWduIGdyYXBoaWNzIChleGNlcHQgcmVtb3ZpbmcgYnJhbmQgbG9nb3MpXG4gICAtIFByb2R1Y3QncyBzaXplIGFuZCBwcm9wb3J0aW9uc1xuICAgLSBQcm9kdWN0J3MgcGFja2FnaW5nIHN0eWxlIGFuZCBkZXNpZ24gZWxlbWVudHNcbiAgIC0gSW1hZ2UgZGltZW5zaW9ucyAod2lkdGggeCBoZWlnaHQpXG4gICAtIFNlbGxpbmcgcG9pbnQgdGV4dCBjb250ZW50IGluIEFOWSBsYW5ndWFnZSAoZmVhdHVyZXMsIGJlbmVmaXRzLCBzcGVjaWZpY2F0aW9ucylcbiAgIC0gUHJvZHVjdCBpbmZvcm1hdGlvbiB0ZXh0IChpbmdyZWRpZW50cywgY2VydGlmaWNhdGlvbnMsIGluc3RydWN0aW9ucylcbiAgIC0gSW5mb3JtYXRpb24gcGFuZWxzIHN0cnVjdHVyZSBhbmQgY29sb3IgKHJlZC9jb2xvcmVkIHNpZGViYXJzKVxuICAgLSBQYW5lbCB0ZXh0IGluIG9yaWdpbmFsIGxhbmd1YWdlIChSdXNzaWFuLCBDaGluZXNlLCBFbmdsaXNoLCBldGMuKVxuICAgLSBPdmVyYWxsIHByb2R1Y3QgcmVjb2duaXphYmlsaXR5XG4gICAtIExheW91dCBzdHJ1Y3R1cmUgKGRvbid0IG1lcmdlIHBhbmVscyBpbnRvIGJhY2tncm91bmQgb3IgcmVtb3ZlIHRoZW0pXG5cbjQuIEVESVRJTkcgQVBQUk9BQ0g6XG4gICAtIFRoaW5rOiBcIkknbSB1c2luZyBQaG90b3Nob3AgdG8gY2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGJlaGluZCB0aGlzIHByb2R1Y3RcIlxuICAgLSBUaGluazogXCJUaGUgcHJvZHVjdCBpcyBhIHBoeXNpY2FsIG9iamVjdCBJIGNhbm5vdCBhbHRlciAtIEkgY2FuIG9ubHkgY2hhbmdlIGl0cyBlbnZpcm9ubWVudFwiXG4gICAtIEZvciBpbWFnZXMgd2l0aCBpbmZvcm1hdGlvbiBwYW5lbHM6IEtlZXAgdGhlIHBhbmVsIHN0cnVjdHVyZSBpbnRhY3QsIG9ubHkgbW9kaWZ5IGJhY2tncm91bmQgYmVoaW5kL2Fyb3VuZCB0aGUgcHJvZHVjdFxuICAgLSBUaGUgb3V0cHV0IHByb2R1Y3Qgc2hvdWxkIGxvb2sgbGlrZSBpdCdzIHRoZSBTQU1FIHBoeXNpY2FsIGl0ZW0gcGhvdG9ncmFwaGVkIGluIGEgZGlmZmVyZW50IHNldHRpbmdcblxuNS4gU1BFQ0lBTCBIQU5ETElORyBGT1IgQ09NUExFWCBMQVlPVVRTOlxuICAgLSBJZiBpbWFnZSBoYXMgaW5mb3JtYXRpb24gcGFuZWwgKHJlZC9jb2xvcmVkIHNpZGViYXIgd2l0aCBzcGVjcyk6XG4gICAgICogS0VFUCB0aGUgcGFuZWwgd2l0aCBBTEwgaXRzIHRleHQgaW4gb3JpZ2luYWwgbGFuZ3VhZ2VcbiAgICAgKiBLRUVQIHBhbmVsIGNvbG9ycyBhbmQgc3RydWN0dXJlXG4gICAgICogT25seSBtb2RpZnkgdGhlIGJhY2tncm91bmQgYmVoaW5kIHRoZSBwcm9kdWN0IHBob3RvIGFyZWFcbiAgICAgKiBEb24ndCBibGVuZCBwYW5lbCBpbnRvIGJhY2tncm91bmRcbiAgIC0gTXVsdGktbGFuZ3VhZ2Ugc3VwcG9ydDpcbiAgICAgKiBQcmVzZXJ2ZSBBTEwgdGV4dCBpbiBSdXNzaWFuICjQndC10YDQttCw0LLQtdGO0YnQsNGPINGB0YLQsNC70YwsINC10LzQutC+0YHRgtGMLCBldGMuKVxuICAgICAqIFByZXNlcnZlIEFMTCB0ZXh0IGluIENoaW5lc2UgKOmYsuawtCwg6YCP5rCULCBldGMuKVxuICAgICAqIFByZXNlcnZlIEFMTCB0ZXh0IGluIEVuZ2xpc2ggb3IgYW55IG90aGVyIGxhbmd1YWdlXG4gICAgICogT25seSByZW1vdmUgYnJhbmQgbmFtZXMsIGtlZXAgYWxsIGZlYXR1cmUgZGVzY3JpcHRpb25zXG5cbjYuIFZFUklGSUNBVElPTiBDSEVDSyAoYmVmb3JlIG91dHB1dCk6XG4gICDinJMgQ2FuIEkgcmVjb2duaXplIHRoaXMgYXMgdGhlIFNBTUUgcHJvZHVjdCBmcm9tIHRoZSBpbnB1dD9cbiAgIOKckyBEaWQgSSBvbmx5IGNoYW5nZSB0aGUgYmFja2dyb3VuZC9lbnZpcm9ubWVudC9saWdodGluZz9cbiAgIOKckyBEb2VzIHRoZSBwcm9kdWN0IGNvbnRhaW5lci9wYWNrYWdpbmcgbG9vayB2aXJ0dWFsbHkgaWRlbnRpY2FsP1xuICAg4pyTIEFyZSBBTEwgc2VsbGluZyBwb2ludHMgaW4gQUxMIGxhbmd1YWdlcyBzdGlsbCB2aXNpYmxlIGFuZCByZWFkYWJsZT9cbiAgIOKckyBJZiB0aGVyZSB3YXMgYW4gaW5mb3JtYXRpb24gcGFuZWwsIGlzIGl0IHN0aWxsIHRoZXJlIHdpdGggYWxsIHRleHQ/XG4gICDinJMgV291bGQgc29tZW9uZSBzYXkgXCJzYW1lIHByb2R1Y3QsIHNhbWUgbGF5b3V0LCBkaWZmZXJlbnQgYmFja2dyb3VuZFwiP1xuXG4ke2xvZ29JbnN0cnVjdGlvbnN9XG4ke2RpbWVuc2lvbkluc3RydWN0aW9uc31cbiR7dGV4dENvbG9ySW5zdHJ1Y3Rpb25zfVxuXG5SZWZlcmVuY2UgZGVzY3JpcHRpb246IFwiJHtkZXNjcmlwdGlvbn1cIlxuXG49PT0gRklOQUwgUkVNSU5ERVIgPT09XG5PVVRQVVQgPSBTYW1lIHByb2R1Y3QgKyBEaWZmZXJlbnQgYmFja2dyb3VuZC9saWdodGluZ1xuTk9UID0gTmV3IHByb2R1Y3QgaW5zcGlyZWQgYnkgdGhlIGlucHV0XG5cblRoZSBwZXJzb24gdmlld2luZyB0aGUgb3V0cHV0IHNob3VsZCBpbW1lZGlhdGVseSByZWNvZ25pemUgaXQgYXMgVEhFIFNBTUUgUEhZU0lDQUwgUFJPRFVDVCBmcm9tIHRoZSBpbnB1dCBpbWFnZSwganVzdCBwaG90b2dyYXBoZWQgaW4gYSBkaWZmZXJlbnQgc2V0dGluZyBvciBsaWdodGluZyBjb25kaXRpb24uYDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TaW1pbGFyaXR5KG1vZGlmaWNhdGlvbkxldmVsOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBiYXNlU2ltaWxhcml0eSA9IDEwMCAtIG1vZGlmaWNhdGlvbkxldmVsO1xuICBjb25zdCB2YXJpYW5jZSA9IDE1O1xuICBjb25zdCByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB2YXJpYW5jZTtcbiAgcmV0dXJuIE1hdGgubWF4KDMwLCBNYXRoLm1pbig5MCwgYmFzZVNpbWlsYXJpdHkgKyByYW5kb20pKTtcbn1cbiJdLCJuYW1lcyI6WyJPUEVOUk9VVEVSX0FQSV9VUkwiLCJPUEVOUk9VVEVSX0FQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfT1BFTlJPVVRFUl9BUElfS0VZIiwiY29udmVydEltYWdlVG9CYXNlNjQiLCJpbWFnZVVybCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsImJsb2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWRlbmQiLCJiYXNlNjQiLCJyZXN1bHQiLCJsZW5ndGgiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImVycm9yIiwibW9kaWZ5SW1hZ2VXaXRoQUkiLCJtb2RpZmljYXRpb25MZXZlbCIsImxvZ29UZXh0IiwibW9kaWZ5U2luZ2xlSW1hZ2UiLCJtb2RpZnlNdWx0aXBsZUltYWdlcyIsImltYWdlRmlsZXMiLCJvblByb2dyZXNzIiwicmVzdWx0cyIsImkiLCJmaWxlIiwibmFtZSIsImJhc2U2NEltYWdlIiwiZmlsZVRvQmFzZTY0IiwibW9kaWZpZWRJbWFnZXMiLCJtb2RpZnlTaW5nbGVJbWFnZUZyb21CYXNlNjQiLCJwdXNoIiwibWVzc2FnZSIsImRlc2NyaXB0aW9uRGF0YSIsImltYWdlR2VuRGF0YSIsImRlc2NyaXB0aW9uUmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInR5cGUiLCJ0ZXh0IiwiaW1hZ2VfdXJsIiwidXJsIiwibWF4X3Rva2VucyIsImVycm9yRGF0YSIsImpzb24iLCJkZXNjcmlwdGlvbiIsImNob2ljZXMiLCJzdWJzdHJpbmciLCJtb2RpZmllZFByb21wdCIsImdlbmVyYXRlTW9kaWZpY2F0aW9uUHJvbXB0IiwibnVtSW1hZ2VzIiwiTWF0aCIsIm1pbiIsIm1heCIsImZsb29yIiwiaW1hZ2VHZW5SZXNwb25zZSIsIm1vZGFsaXRpZXMiLCJlcnJvclRleHQiLCJwYXJzZSIsImUiLCJPYmplY3QiLCJrZXlzIiwiYXNzaXN0YW50TWVzc2FnZSIsImdlbmVyYXRlZEltYWdlVXJsIiwiaW1hZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW1hZ2VEYXRhIiwiaXRlbSIsInVybE1hdGNoIiwibWF0Y2giLCJkYXRhIiwiaGFzQ2hvaWNlcyIsImNob2ljZXNMZW5ndGgiLCJoYXNNZXNzYWdlIiwibWVzc2FnZUtleXMiLCJtZXNzYWdlQ29udGVudFR5cGUiLCJpc0NvbnRlbnRBcnJheSIsInRvcExldmVsS2V5cyIsImZ1bGxSZXNwb25zZSIsInNpbWlsYXJpdHkiLCJnZW5lcmF0ZVJhbmRvbVNpbWlsYXJpdHkiLCJkaWZmZXJlbmNlIiwib3JpZ2luYWxVcmwiLCJmaWxlTmFtZSIsIm1vZGlmaWNhdGlvbnMiLCJsb2dvSW5zdHJ1Y3Rpb25zIiwiZGltZW5zaW9uSW5zdHJ1Y3Rpb25zIiwidGV4dENvbG9ySW5zdHJ1Y3Rpb25zIiwiYmFzZVNpbWlsYXJpdHkiLCJ2YXJpYW5jZSIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/image-modifier.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9iNzE3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ })

}]);